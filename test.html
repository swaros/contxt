
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>taskrun: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/swaros/contxt/taskrun/checker.go (90.1%)</option>
				
				<option value="file1">github.com/swaros/contxt/taskrun/cmdflow.go (60.1%)</option>
				
				<option value="file2">github.com/swaros/contxt/taskrun/cmdhandl.go (56.8%)</option>
				
				<option value="file3">github.com/swaros/contxt/taskrun/export.go (47.8%)</option>
				
				<option value="file4">github.com/swaros/contxt/taskrun/interactive.go (0.0%)</option>
				
				<option value="file5">github.com/swaros/contxt/taskrun/labelprint.go (82.8%)</option>
				
				<option value="file6">github.com/swaros/contxt/taskrun/lint.go (3.1%)</option>
				
				<option value="file7">github.com/swaros/contxt/taskrun/mirror.go (0.0%)</option>
				
				<option value="file8">github.com/swaros/contxt/taskrun/parshlp.go (100.0%)</option>
				
				<option value="file9">github.com/swaros/contxt/taskrun/placeholder.go (77.8%)</option>
				
				<option value="file10">github.com/swaros/contxt/taskrun/runner.go (2.2%)</option>
				
				<option value="file11">github.com/swaros/contxt/taskrun/shareduse.go (3.0%)</option>
				
				<option value="file12">github.com/swaros/contxt/taskrun/shellinstall.go (0.0%)</option>
				
				<option value="file13">github.com/swaros/contxt/taskrun/taskrunner.go (0.0%)</option>
				
				<option value="file14">github.com/swaros/contxt/taskrun/taskwatcher.go (83.3%)</option>
				
				<option value="file15">github.com/swaros/contxt/taskrun/taskwriter.go (0.0%)</option>
				
				<option value="file16">github.com/swaros/contxt/taskrun/template.go (48.1%)</option>
				
				<option value="file17">github.com/swaros/contxt/taskrun/vardata.go (76.0%)</option>
				
				<option value="file18">github.com/swaros/contxt/taskrun/varimport.go (72.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package taskrun

import (
        "fmt"
        "os"
        "strings"

        "github.com/sirupsen/logrus"
        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/dirhandle"
)

// test all rwuirements
// - operation system
// - variable matches
// - files exists
// - files not exists
// - environment variables
// returns bool and the message what is checked.
func checkRequirements(require configure.Require) (bool, string) <span class="cov8" title="1">{

        // check operating system
        if require.System != "" </span><span class="cov8" title="1">{
                match := StringMatchTest(require.System, configure.GetOs())
                if !match </span><span class="cov8" title="1">{
                        return false, "operating system '" + configure.GetOs() + "' is not matching with '" + require.System + "'"
                }</span>
        }

        // check file exists
        <span class="cov8" title="1">for _, fileExists := range require.Exists </span><span class="cov8" title="1">{
                fileExists = HandlePlaceHolder(fileExists)
                fexists, err := dirhandle.Exists(fileExists)
                GetLogger().WithFields(logrus.Fields{
                        "path":   fileExists,
                        "result": fexists,
                }).Debug("path exists? result=true means valid for require")
                if err != nil || !fexists </span><span class="cov0" title="0">{

                        return false, "required file (" + fileExists + ") not found "
                }</span>
        }

        // check file not exists
        <span class="cov8" title="1">for _, fileNotExists := range require.NotExists </span><span class="cov8" title="1">{
                fileNotExists = HandlePlaceHolder(fileNotExists)
                fexists, err := dirhandle.Exists(fileNotExists)
                GetLogger().WithFields(logrus.Fields{
                        "path":   fileNotExists,
                        "result": fexists,
                }).Debug("path NOT exists? result=true means not valid for require")
                if err != nil || fexists </span><span class="cov8" title="1">{
                        return false, "unexpected file (" + fileNotExists + ")  found "
                }</span>
        }

        // check environment variable is set
        <span class="cov8" title="1">for name, pattern := range require.Environment </span><span class="cov8" title="1">{
                envVar, envExists := os.LookupEnv(name)
                if !envExists || !StringMatchTest(pattern, envVar) </span><span class="cov8" title="1">{
                        if envExists </span><span class="cov0" title="0">{
                                return false, "environment variable[" + name + "] not matching with " + pattern
                        }</span>
                        <span class="cov8" title="1">return false, "environment variable[" + name + "] not exists"</span>
                }
        }

        // check variables
        <span class="cov8" title="1">for name, pattern := range require.Variables </span><span class="cov8" title="1">{
                defVar, defExists := GetPHExists(name)
                if !defExists || !StringMatchTest(pattern, defVar) </span><span class="cov8" title="1">{
                        if defExists </span><span class="cov0" title="0">{
                                return false, "runtime variable[" + name + "] not matching with " + pattern
                        }</span>
                        <span class="cov8" title="1">return false, "runtime variable[" + name + "] not exists "</span>
                }
        }

        <span class="cov8" title="1">return true, ""</span>
}

// StringMatchTest test a pattern and a value.
// in this example: myvar: "=hello"
// the patter is "=hello" and the value should be "hello" for a match
func StringMatchTest(pattern, value string) bool <span class="cov8" title="1">{
        first := pattern
        maybeMatch := value
        if len(pattern) &gt; 1 </span><span class="cov8" title="1">{
                maybeMatch = pattern[1:]
                first = pattern[0:1]
        }</span>
        <span class="cov8" title="1">switch first </span>{
        // string not empty
        case "?":<span class="cov8" title="1">
                GetLogger().WithFields(logrus.Fields{"pattern": pattern, "value": value, "check": first, "result": (value != "")}).Debug("check anything then empty")
                return (value != "")</span>

        // string equals
        case "=":<span class="cov8" title="1">
                GetLogger().WithFields(logrus.Fields{"pattern": maybeMatch, "value": value, "check": first, "result": (maybeMatch == value)}).Debug("check equal")
                return (maybeMatch == value)</span>

        // string not equals
        case "!":<span class="cov8" title="1">
                GetLogger().WithFields(logrus.Fields{"pattern": maybeMatch, "value": value, "check": first, "result": (maybeMatch != value)}).Debug("check not equal")
                return (maybeMatch != value)</span>

        // string greater
        case "&gt;":<span class="cov8" title="1">
                GetLogger().WithFields(logrus.Fields{"pattern": maybeMatch, "value": value, "check": first, "result": (maybeMatch &lt; value)}).Debug("check greather then")
                return (value &gt; maybeMatch)</span>

        // sstring lower
        case "&lt;":<span class="cov8" title="1">
                GetLogger().WithFields(logrus.Fields{"pattern": maybeMatch, "value": value, "check": first, "result": (maybeMatch &gt; value)}).Debug("check lower then")
                return (value &lt; maybeMatch)</span>

        // string not empty
        case "*":<span class="cov8" title="1">
                GetLogger().WithFields(logrus.Fields{"pattern": maybeMatch, "value": value, "check": first, "result": (value != "")}).Debug("check empty *")
                return (value != "")</span>

        // default is checking equals
        default:<span class="cov8" title="1">
                GetLogger().WithFields(logrus.Fields{"pattern": pattern, "value": value, "check": first, "result": (pattern == value)}).Debug("default: check equal against plain values")
                return (pattern == value)</span>
        }
}

// checks reasons that is used for some triggers
// retunrs bool and a message what trigger was matched and the reason
func checkReason(checkReason configure.Trigger, output string, e error) (bool, string) <span class="cov8" title="1">{
        GetLogger().WithFields(logrus.Fields{
                "contains":   checkReason.OnoutContains,
                "onError":    checkReason.Onerror,
                "onLess":     checkReason.OnoutcountLess,
                "onMore":     checkReason.OnoutcountMore,
                "testing-at": output,
        }).Debug("Checking Trigger")

        var message = ""
        // now means forcing this trigger
        if checkReason.Now </span><span class="cov0" title="0">{
                message = "reason now match always"
                return true, message
        }</span>
        // checks a error happens
        <span class="cov8" title="1">if checkReason.Onerror &amp;&amp; e != nil </span><span class="cov8" title="1">{
                message = fmt.Sprint("reason match because a error happen (", e, ")  ")
                return true, message
        }</span>

        // checks if the output from comand contains les then X chars
        <span class="cov8" title="1">if checkReason.OnoutcountLess &gt; 0 &amp;&amp; checkReason.OnoutcountLess &gt; len(output) </span><span class="cov0" title="0">{
                message = fmt.Sprint("reason match output len (", len(output), ") is less then ", checkReason.OnoutcountLess)
                return true, message
        }</span>
        // checks if the output contains more then X chars
        <span class="cov8" title="1">if checkReason.OnoutcountMore &gt; 0 &amp;&amp; checkReason.OnoutcountMore &lt; len(output) </span><span class="cov8" title="1">{
                message = fmt.Sprint("reason match output len (", len(output), ") is more then ", checkReason.OnoutcountMore)
                return true, message
        }</span>

        // checks if the output contains one of the defined text-lines
        <span class="cov8" title="1">for _, checkText := range checkReason.OnoutContains </span><span class="cov8" title="1">{
                checkText = HandlePlaceHolder(checkText)
                if checkText != "" &amp;&amp; strings.Contains(output, checkText) </span><span class="cov8" title="1">{
                        message = fmt.Sprint("reason match because output contains ", checkText)
                        return true, message
                }</span>
                <span class="cov8" title="1">if checkText != "" </span><span class="cov8" title="1">{
                        GetLogger().WithFields(logrus.Fields{
                                "check": checkText,
                                "with":  output,
                                "from":  checkReason.OnoutContains,
                        }).Debug("OnoutContains NO MATCH")
                }</span>
        }

        <span class="cov8" title="1">return false, message</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "context"
        "fmt"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/imdario/mergo"
        "github.com/sirupsen/logrus"
        "github.com/swaros/contxt/awaitgroup"
        "github.com/swaros/contxt/dirhandle"
        "github.com/swaros/manout"

        "github.com/swaros/contxt/systools"

        "github.com/swaros/contxt/configure"
)

const (
        // ExitOk the process was executed without errors
        ExitOk = 0
        // ExitByStopReason the process stopped because of a defined reason
        ExitByStopReason = 101
        // ExitNoCode means there was no code associated
        ExitNoCode = 102
        // ExitCmdError means the execution of the command fails. a error by the command itself
        ExitCmdError = 103
        // ExitByRequirement means a requirement was not fulfills
        ExitByRequirement = 104
        // ExitAlreadyRunning means the task is not started, because it is already created
        ExitAlreadyRunning = 105
)

// this flag is for the runner logic replacement that have still issues.
// this 'solution' is not nice but a different branch would be more difficult to handle
var Experimental = true

// SharedFolderExecuter runs shared .contxt.yml files directly without merging them into
// the current contxt file
func SharedFolderExecuter(template configure.RunConfig, locationHandle func(string, string)) <span class="cov0" title="0">{
        if len(template.Config.Use) &gt; 0 </span><span class="cov0" title="0">{
                GetLogger().WithField("uses", template.Config.Use).Info("shared executer")
                for _, shared := range template.Config.Use </span><span class="cov0" title="0">{
                        externalPath := HandleUsecase(shared)
                        GetLogger().WithField("path", externalPath).Info("shared contxt location")
                        currentDir, _ := dirhandle.Current()
                        os.Chdir(externalPath)
                        locationHandle(externalPath, currentDir)
                        os.Chdir(currentDir)
                }</span>
        }
}

func RunShared(targets string) <span class="cov8" title="1">{

        allTargets := strings.Split(targets, ",")
        template, templatePath, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                CtxOut(manout.MessageCln(manout.ForeRed, "Error ", manout.CleanTag, terr.Error()))
                return
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if template.Config.Loglevel != "" </span><span class="cov8" title="1">{ // set logger level by template definition
                setLogLevelByString(template.Config.Loglevel)
        }</span>

        <span class="cov8" title="1">GetLogger().WithField("targets", allTargets).Info("SHARED START run targets...")

        // handle all shared usages. these usages are set
        // in the template by the string map named Use in the config section
        // Config:
        //    Use:
        //      - shared_task_1
        //      - shared_task_2
        if len(template.Config.Use) &gt; 0 </span><span class="cov0" title="0">{
                GetLogger().WithField("uses", template.Config.Use).Info("found external dependecy")
                CtxOut(manout.MessageCln(manout.ForeCyan, "[SHARED loop]"))
                for _, shared := range template.Config.Use </span><span class="cov0" title="0">{
                        CtxOut(manout.MessageCln(manout.ForeCyan, "[SHARED CONTXT][", manout.ForeBlue, shared, manout.ForeCyan, "] "))
                        externalPath := HandleUsecase(shared)
                        GetLogger().WithField("path", externalPath).Info("shared contxt location")
                        currentDir, _ := dirhandle.Current()
                        os.Chdir(externalPath)
                        for _, runTarget := range allTargets </span><span class="cov0" title="0">{
                                CtxOut(manout.MessageCln(manout.ForeCyan, manout.ForeGreen, runTarget, manout.ForeYellow, " [ external:", manout.ForeWhite, externalPath, manout.ForeYellow, "] ", manout.ForeDarkGrey, templatePath))
                                RunTargets(runTarget, false)
                                CtxOut(manout.MessageCln(manout.ForeCyan, "["+manout.ForeBlue, shared+"] ", manout.ForeGreen, runTarget, " DONE"))
                        }</span>
                        <span class="cov0" title="0">os.Chdir(currentDir)</span>
                }
                <span class="cov0" title="0">CtxOut(manout.MessageCln(manout.ForeCyan, "[SHARED done]"))</span>
        }
        <span class="cov8" title="1">GetLogger().WithField("targets", allTargets).Info("  SHARED DONE run targets...")</span>
}

// RunTargets executes multiple targets
// the targets string can have multiple targets
// seperated by comma
func RunTargets(targets string, sharedRun bool) <span class="cov8" title="1">{

        // validate first
        if err := TestTemplate(); err != nil </span><span class="cov0" title="0">{
                CtxOut("found issues in the current template ", err)
                systools.Exit(32)
                return
        }</span>

        <span class="cov8" title="1">SetPH("CTX_TARGETS", targets)

        // this flag should only true on the first execution
        if sharedRun </span><span class="cov8" title="1">{
                // do it here makes sure we are not in the shared scope
                currentDir, _ := dirhandle.Current()
                SetPH("CTX_PWD", currentDir)
                // run shared use
                RunShared(targets)
        }</span>

        <span class="cov8" title="1">allTargets := strings.Split(targets, ",")
        template, templatePath, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                CtxOut(manout.MessageCln(manout.ForeRed, "Error ", manout.CleanTag, terr.Error()))
                systools.Exit(33)
                return
        }</span>
        <span class="cov8" title="1">GetLogger().WithField("targets", allTargets).Info("run targets...")
        var runSequencially = false // default is async mode
        if exists </span><span class="cov8" title="1">{                 // TODO: the exists check just for this config reading seems wrong
                runSequencially = template.Config.Sequencially
                if template.Config.Coloroff </span><span class="cov8" title="1">{
                        manout.ColorEnabled = false
                }</span>
        }

        <span class="cov8" title="1">if template.Config.Loglevel != "" </span><span class="cov8" title="1">{ // loglevel by config
                setLogLevelByString(template.Config.Loglevel)
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup // the main waitgroup

        // handle all imports.
        // these are yaml or json files, they can be accessed for reading by the gson doted format
        if len(template.Config.Imports) &gt; 0 </span><span class="cov8" title="1">{
                GetLogger().WithField("Import", template.Config.Imports).Info("import second level vars")
                handleFileImportsToVars(template.Config.Imports)
        }</span> else<span class="cov8" title="1"> {
                GetLogger().Info("No second level Variables defined")
        }</span>

        // experimental usage of taskrunner
        <span class="cov8" title="1">if Experimental </span><span class="cov8" title="1">{
                if runSequencially </span><span class="cov8" title="1">{ // non async run
                        for _, trgt := range allTargets </span><span class="cov8" title="1">{
                                SetPH("CTX_TARGET", trgt)
                                CtxOut(LabelFY("exec"), InfoMinor("execute target in sequence"), ValF(trgt), manout.ForeLightCyan, " ", templatePath)
                                ExecPathFile(&amp;wg, !runSequencially, template, trgt)
                        }</span>
                } else<span class="cov8" title="1"> {
                        var futuresExecs []awaitgroup.FutureStack
                        for _, trgt := range allTargets </span><span class="cov8" title="1">{ // iterate all targets
                                CtxOut(LabelFY("exec"), InfoMinor("execute target in Async"), ValF(trgt), manout.ForeLightCyan, " ", templatePath)
                                futuresExecs = append(futuresExecs, awaitgroup.FutureStack{
                                        AwaitFunc: func(ctx context.Context) interface{} </span><span class="cov8" title="1">{
                                                ctxTarget := ctx.Value(awaitgroup.CtxKey{}).(string)            // get the target from context
                                                SetPH("CTX_TARGET", ctxTarget)                                  // update global target. TODO: makes this any sense in async?
                                                return ExecPathFile(&amp;wg, !runSequencially, template, ctxTarget) // execute target
                                        }</span>,
                                        Argument: trgt,
                                })
                        }
                        <span class="cov8" title="1">futures := awaitgroup.ExecFutureGroup(futuresExecs)           // execute all async task
                        CtxOut(LabelFY("exec"), "all targets started ", len(targets)) // just info
                        awaitgroup.WaitAtGroup(futures)                               // wait until all task are done
                        CtxOut(LabelFY("exec"), "all targets done ", len(targets))</span>    // also just info for the user
                }

        } else<span class="cov0" title="0"> {
                // NONE experimental usage of taskrunner
                if !runSequencially </span><span class="cov0" title="0">{
                        // run in thread
                        for _, runTarget := range allTargets </span><span class="cov0" title="0">{
                                SetPH("CTX_TARGET", runTarget)
                                wg.Add(1)
                                CtxOut(manout.MessageCln(manout.ForeBlue, "[exec:async] ", manout.BoldTag, runTarget, " ", manout.ForeWhite, templatePath))
                                go ExecuteTemplateWorker(&amp;wg, true, runTarget, template)
                        }</span>
                        <span class="cov0" title="0">wg.Wait()</span>
                } else<span class="cov0" title="0"> {
                        // trun one by one
                        for _, runTarget := range allTargets </span><span class="cov0" title="0">{
                                SetPH("CTX_TARGET", runTarget)
                                CtxOut(manout.MessageCln(manout.ForeBlue, "[exec:seq] ", manout.BoldTag, runTarget, " ", manout.ForeWhite, templatePath))
                                exitCode := ExecPathFile(&amp;wg, false, template, runTarget)
                                GetLogger().WithField("exitcode", exitCode).Info("RunTarget [Sequencially runmode] done with exitcode")
                        }</span>
                }
        }

        <span class="cov8" title="1">CtxOut(manout.MessageCln(manout.ForeBlue, "[done] ", manout.BoldTag, targets))
        GetLogger().Info("target task execution done")</span>
}

func setLogLevelByString(loglevel string) <span class="cov8" title="1">{
        level, err := logrus.ParseLevel(loglevel)
        if err != nil </span><span class="cov0" title="0">{
                GetLogger().Error("Invalid loglevel in task defined.", err)
        }</span> else<span class="cov8" title="1"> {
                GetLogger().SetLevel(level)
        }</span>

}

func listenerWatch(script configure.Task, target, logLine string, e error, waitGroup *sync.WaitGroup, useWaitGroup bool, runCfg configure.RunConfig) <span class="cov8" title="1">{
        if script.Listener != nil </span><span class="cov8" title="1">{

                GetLogger().WithFields(logrus.Fields{
                        "count":    len(script.Listener),
                        "listener": script.Listener,
                }).Debug("testing Listener")

                for _, listener := range script.Listener </span><span class="cov8" title="1">{
                        triggerFound, triggerMessage := checkReason(listener.Trigger, logLine, e) // check if a trigger have a match
                        if triggerFound </span><span class="cov8" title="1">{
                                SetPH("RUN."+target+".LOG.HIT", logLine)
                                if script.Options.Displaycmd </span><span class="cov8" title="1">{
                                        CtxOut(manout.MessageCln(manout.ForeCyan, "[trigger]\t", manout.ForeYellow, triggerMessage, manout.Dim, " ", logLine))
                                }</span>

                                <span class="cov8" title="1">someReactionTriggered := false                 // did this trigger something? used as flag
                                actionDef := configure.Action(listener.Action) // extract action

                                if len(actionDef.Script) &gt; 0 </span><span class="cov0" title="0">{ // script are directs executes without any async or other executes out of scope
                                        someReactionTriggered = true
                                        var dummyArgs map[string]string = make(map[string]string) // create empty arguments as scoped values
                                        for _, triggerScript := range actionDef.Script </span><span class="cov0" title="0">{          // run any line of script
                                                GetLogger().WithFields(logrus.Fields{
                                                        "cmd": triggerScript,
                                                }).Debug("TRIGGER SCRIPT ACTION")
                                                lineExecuter(waitGroup, useWaitGroup, script.Stopreasons, runCfg, "93", "46", triggerScript, target, dummyArgs, script)
                                        }</span>

                                }

                                <span class="cov8" title="1">if actionDef.Target != "" </span><span class="cov8" title="1">{ // here we have a target defined thats needs to be started
                                        someReactionTriggered = true
                                        GetLogger().WithFields(logrus.Fields{
                                                "target": actionDef.Target,
                                        }).Debug("TRIGGER ACTION")

                                        if script.Options.Displaycmd </span><span class="cov8" title="1">{
                                                CtxOut(manout.MessageCln(manout.ForeCyan, "[trigger]\t ", manout.ForeGreen, "target:", manout.ForeLightGreen, actionDef.Target))
                                        }</span>

                                        // TODO: i can't remember why i am doing this placeholder thing
                                        <span class="cov8" title="1">hitKeyTargets := "RUN.LISTENER." + target + ".HIT.TARGETS" // compose the placeholder key
                                        lastHitTargets := GetPH(hitKeyTargets)                     // get the last stored value if exists
                                        if !strings.Contains(lastHitTargets, "("+actionDef.Target+")") </span><span class="cov8" title="1">{
                                                lastHitTargets = lastHitTargets + "(" + actionDef.Target + ")"
                                                SetPH(hitKeyTargets, lastHitTargets)
                                        }</span>

                                        <span class="cov8" title="1">hitKeyCnt := "RUN.LISTENER." + actionDef.Target + ".HIT.CNT"
                                        lastCnt := GetPH(hitKeyCnt)
                                        if lastCnt == "" </span><span class="cov8" title="1">{
                                                SetPH(hitKeyCnt, "1")
                                        }</span> else<span class="cov0" title="0"> {
                                                iCnt, err := strconv.Atoi(lastCnt)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        GetLogger().Fatal("fail converting trigger count")
                                                }</span>
                                                <span class="cov0" title="0">iCnt++
                                                SetPH(hitKeyCnt, strconv.Itoa(iCnt))</span>
                                        }

                                        <span class="cov8" title="1">GetLogger().WithFields(logrus.Fields{
                                                "trigger":   triggerMessage,
                                                "target":    actionDef.Target,
                                                "waitgroup": useWaitGroup,
                                                "RUN.LISTENER." + target + ".HIT.TARGETS": lastHitTargets,
                                        }).Info("TRIGGER Called")
                                        var scopeVars map[string]string = make(map[string]string)

                                        if Experimental </span><span class="cov8" title="1">{
                                                GetLogger().WithFields(logrus.Fields{
                                                        "target": actionDef.Target,
                                                }).Info("RUN Triggered target (not async)")

                                                // because we are anyway in a async scope, we should no longer
                                                // try to run this target too async.
                                                // also the target is triggered by an specific log entriy, it makes
                                                // sence to stop the execution of the parent, til this target is executed
                                                CtxOut("running target ", manout.ForeCyan, actionDef.Target, manout.ForeLightCyan, " trigger action")
                                                executeTemplate(waitGroup, useWaitGroup, runCfg, actionDef.Target, scopeVars)
                                        }</span> else<span class="cov0" title="0"> {

                                                if useWaitGroup </span><span class="cov0" title="0">{
                                                        GetLogger().WithFields(logrus.Fields{
                                                                "target": actionDef.Target,
                                                        }).Info("RUN ASYNC")

                                                        go executeTemplate(waitGroup, useWaitGroup, runCfg, actionDef.Target, scopeVars)

                                                }</span> else<span class="cov0" title="0"> {
                                                        GetLogger().WithFields(logrus.Fields{
                                                                "target": actionDef.Target,
                                                        }).Info("RUN SEQUENCE")
                                                        executeTemplate(waitGroup, useWaitGroup, runCfg, actionDef.Target, scopeVars)
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">if !someReactionTriggered </span><span class="cov0" title="0">{
                                        GetLogger().WithFields(logrus.Fields{
                                                "trigger": triggerMessage,
                                                "output":  logLine,
                                        }).Warn("trigger defined without any action")
                                }</span>
                        } else<span class="cov8" title="1"> {
                                GetLogger().WithFields(logrus.Fields{
                                        "output": logLine,
                                }).Debug("no trigger found")
                        }</span>
                }
        }
}

// the main script handler
func lineExecuter(
        waitGroup *sync.WaitGroup, // the main waitgoup
        useWaitGroup bool, // flag if we have to use the waitgroup. also means we run in async mode
        stopReason configure.Trigger, // configuration for the stop reasons
        runCfg configure.RunConfig, // the runtime configuration
        colorCode, bgCode, // colorcodes for the left panel
        codeLine, // the script that have to be processed
        target string, // the actual target
        arguments map[string]string, // the arguments for the current scope
        script configure.Task) (int, bool) <span class="cov8" title="1">{
        panelSize := 12                   // default panelsize
        if script.Options.Panelsize &gt; 0 </span><span class="cov0" title="0">{ // overwrite panel size if set
                panelSize = script.Options.Panelsize
        }</span>
        <span class="cov8" title="1">var mainCommand = defaultString(script.Options.Maincmd, DefaultCommandFallBack) // get the maincommand by default first
        if configure.GetOs() == "windows" </span><span class="cov0" title="0">{                                             // handle windows behavior depending default commands
                mainCommand = defaultString(script.Options.Maincmd, DefaultCommandFallBackWindows)
        }</span>
        <span class="cov8" title="1">replacedLine := HandlePlaceHolderWithScope(codeLine, arguments) // placeholders
        if script.Options.Displaycmd </span><span class="cov8" title="1">{                                  // do we show the argument?
                CtxOut(LabelFY("cmd"), ValF(target), InfoF(replacedLine))
        }</span>

        <span class="cov8" title="1">SetPH("RUN.SCRIPT_LINE", replacedLine) // overwrite the current scriptline. this is only reliable if we not in async mode
        var targetLabel CtxTargetOut = CtxTargetOut{
                ForeCol:   defaultString(script.Options.Colorcode, colorCode),
                BackCol:   defaultString(script.Options.Bgcolorcode, bgCode),
                PanelSize: panelSize,
        }
        // here we execute the current script line
        execCode, realExitCode, execErr := ExecuteScriptLine(mainCommand, script.Options.Mainparams, replacedLine,
                func(logLine string, err error) bool </span><span class="cov8" title="1">{ // callback for any logline

                        SetPH("RUN."+target+".LOG.LAST", logLine) // set or overwrite the last script output for the target

                        if script.Listener != nil </span><span class="cov8" title="1">{ // do we have listener?
                                GetLogger().WithFields(logrus.Fields{
                                        "cnt":      len(script.Listener),
                                        "listener": script.Listener,
                                }).Debug("CHECK Listener")
                                listenerWatch(script, target, logLine, err, waitGroup, useWaitGroup, runCfg) // listener handler
                        }</span>
                        <span class="cov8" title="1">targetLabel.Target = target
                        // The whole output can be ignored by configuration
                        // if this is not enabled then we handle all these here
                        if !script.Options.Hideout </span><span class="cov8" title="1">{
                                // the background color
                                if script.Options.Format != "" </span><span class="cov8" title="1">{ // do we have a specific format for the label, then we use them instead
                                        format := HandlePlaceHolderWithScope(script.Options.Format, script.Variables) // handle placeholder in the label
                                        fomatedOutStr := manout.Message(fmt.Sprintf(format, target))                  // also format the message depending format codes
                                        targetLabel.Alternative = fomatedOutStr
                                }</span>

                                //outStr := systools.LabelPrintWithArg(logLine, colorCode, "39", 2) // hardcoded format for the logoutput iteself
                                <span class="cov8" title="1">outStr := manout.MessageCln(logLine)
                                if script.Options.Stickcursor </span><span class="cov0" title="0">{ // optional set back the cursor to the beginning
                                        fmt.Print("\033[G\033[K") // done by escape codes
                                }</span>

                                <span class="cov8" title="1">CtxOut(targetLabel, outStr)     // prints the codeline
                                if script.Options.Stickcursor </span><span class="cov0" title="0">{ // cursor stick handling
                                        fmt.Print("\033[A")
                                }</span>
                        }

                        <span class="cov8" title="1">stopReasonFound, message := checkReason(stopReason, logLine, err) // do we found a defined reason to stop execution
                        if stopReasonFound </span><span class="cov8" title="1">{
                                if script.Options.Displaycmd </span><span class="cov8" title="1">{
                                        CtxOut(LabelFY("stop-reason"), ValF(message))
                                }</span>
                                <span class="cov8" title="1">return false</span>
                        }
                        <span class="cov8" title="1">return true</span>
                }, func(process *os.Process) <span class="cov8" title="1">{ // callback if the process started and we got the process id
                        pidStr := fmt.Sprintf("%d", process.Pid) // we use them as info for the user only
                        SetPH("RUN.PID", pidStr)
                        SetPH("RUN."+target+".PID", pidStr)
                        if script.Options.Displaycmd </span><span class="cov8" title="1">{
                                CtxOut(LabelFY("pid"), ValF(process.Pid))
                        }</span>
                })
        <span class="cov8" title="1">if execErr != nil </span><span class="cov8" title="1">{
                if script.Options.Displaycmd </span><span class="cov8" title="1">{
                        CtxOut(LabelErrF("exec error"), ValF(execErr))
                }</span>
        }
        // check execution codes
        <span class="cov8" title="1">switch execCode </span>{
        case ExitByStopReason:<span class="cov8" title="1">
                return ExitByStopReason, true</span>
        case ExitCmdError:<span class="cov8" title="1">
                if script.Options.IgnoreCmdError </span><span class="cov8" title="1">{
                        if script.Stopreasons.Onerror </span><span class="cov8" title="1">{
                                return ExitByStopReason, true
                        }</span>
                        <span class="cov0" title="0">CtxOut(manout.MessageCln(manout.ForeYellow, "NOTE!\t", manout.BackLightYellow, manout.ForeDarkGrey, " a script execution was failing. no stopreason is set so execution will continued "))
                        CtxOut(manout.MessageCln("\t", manout.BackLightYellow, manout.ForeDarkGrey, " if this is expected you can ignore this message.                                 "))
                        CtxOut(manout.MessageCln("\t", manout.BackLightYellow, manout.ForeDarkGrey, " but you should handle error cases                                                "))
                        CtxOut("\ttarget :\t", manout.MessageCln(manout.ForeYellow, target))
                        CtxOut("\tcommand:\t", manout.MessageCln(manout.ForeYellow, codeLine))</span>

                } else<span class="cov0" title="0"> {
                        errMsg := " = exit code from command: "
                        lastMessage := manout.MessageCln(manout.BackRed, manout.ForeYellow, realExitCode, manout.CleanTag, manout.ForeLightRed, errMsg, manout.ForeWhite, codeLine)
                        CtxOut("\t Exit ", lastMessage)
                        CtxOut()
                        CtxOut("\t check the command. if this command can fail you may fit the execution rules. see options:")
                        CtxOut("\t you may disable a hard exit on error by setting ignoreCmdError: true")
                        CtxOut("\t if you do so, a Note will remind you, that a error is happend in this case.")
                        CtxOut()
                        GetLogger().Error("runtime error:", execErr, "exit", realExitCode)
                        systools.Exit(realExitCode)
                        // returns the error code
                        return ExitCmdError, true
                }</span>
        case ExitOk:<span class="cov8" title="1">
                return ExitOk, false</span>
        }
        <span class="cov0" title="0">return ExitNoCode, true</span>
}

func generateFuturesByTargetListAndExec(RunTargets []string, waitGroup *sync.WaitGroup, runCfg configure.RunConfig) []awaitgroup.Future <span class="cov8" title="1">{
        if len(RunTargets) &lt; 1 </span><span class="cov8" title="1">{
                return []awaitgroup.Future{}
        }</span>
        <span class="cov8" title="1">var runTargetExecs []awaitgroup.FutureStack
        for _, needTarget := range RunTargets </span><span class="cov8" title="1">{
                GetLogger().Debug("runTarget name should be added " + needTarget)
                runTargetExecs = append(runTargetExecs, awaitgroup.FutureStack{
                        AwaitFunc: func(ctx context.Context) interface{} </span><span class="cov8" title="1">{
                                argTask := ctx.Value(awaitgroup.CtxKey{}).(string)
                                _, argmap := StringSplitArgs(argTask, "arg")
                                GetLogger().Debug("add runTarget task " + argTask)
                                return executeTemplate(waitGroup, true, runCfg, argTask, argmap)
                        }</span>,
                        Argument: needTarget})

        }
        <span class="cov8" title="1">CtxOut(LabelFY("async targets"), InfoF("count"), len(runTargetExecs), InfoF(" targets"))
        return awaitgroup.ExecFutureGroup(runTargetExecs)</span>
}

// merge a list of task to an single task.
func mergeTargets(target string, runCfg configure.RunConfig) configure.Task <span class="cov0" title="0">{
        var checkTasks configure.Task
        first := true
        if len(runCfg.Task) &gt; 0 </span><span class="cov0" title="0">{
                for _, script := range runCfg.Task </span><span class="cov0" title="0">{
                        if strings.EqualFold(target, script.ID) </span><span class="cov0" title="0">{
                                canRun, failMessage := checkRequirements(script.Requires)
                                if canRun </span><span class="cov0" title="0">{
                                        // update task variables
                                        for keyName, variable := range script.Variables </span><span class="cov0" title="0">{
                                                SetPH(keyName, HandlePlaceHolder(variable))
                                        }</span>
                                        <span class="cov0" title="0">if first </span><span class="cov0" title="0">{
                                                checkTasks = script
                                                first = false
                                        }</span> else<span class="cov0" title="0"> {
                                                mergo.Merge(&amp;checkTasks, script, mergo.WithOverride, mergo.WithAppendSlice)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        GetLogger().Debug(failMessage)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return checkTasks</span>
}

func executeTemplate(waitGroup *sync.WaitGroup, runAsync bool, runCfg configure.RunConfig, target string, scopeVars map[string]string) int <span class="cov8" title="1">{
        if runAsync </span><span class="cov8" title="1">{
                waitGroup.Add(1)
                defer waitGroup.Done()
        }</span>
        // check if task is already running
        // this check depends on the target name.
        <span class="cov8" title="1">if !runCfg.Config.AllowMutliRun &amp;&amp; TaskRunning(target) </span><span class="cov0" title="0">{
                GetLogger().WithField("task", target).Warning("task would be triggered again while is already running. IGNORED")
                return ExitAlreadyRunning
        }</span>
        // increment task counter
        <span class="cov8" title="1">incTaskCount(target)
        defer incTaskDoneCount(target)

        GetLogger().WithFields(logrus.Fields{
                "target": target,
        }).Info("executeTemplate LOOKING for target")

        // Checking if the Tasklist have something
        // to handle
        if len(runCfg.Task) &gt; 0 </span><span class="cov8" title="1">{
                returnCode := ExitOk

                // the main variables will be set at first
                // but only if the they not already exists
                // from other task or by start argument
                for keyName, variable := range runCfg.Config.Variables </span><span class="cov8" title="1">{
                        SetIfNotExists(keyName, HandlePlaceHolder(variable))
                }</span>
                // set the colorcodes for the labels on left side of screen
                <span class="cov8" title="1">colorCode, bgCode := systools.CreateColorCode()

                // updates global variables
                SetPH("RUN.TARGET", target)

                // this flag is only used
                // for a "target not found" message later
                targetFound := false

                // oure tasklist that will use later
                var taskList []configure.Task

                // depending on the config
                // we merge the tasks and handle them as one task,
                // or we keep them as a list of tasks what would
                // keep more flexibility.
                // by merging task we can loose runtime definitions
                if runCfg.Config.MergeTasks </span><span class="cov0" title="0">{
                        mergedScript := mergeTargets(target, runCfg)
                        taskList = append(taskList, mergedScript)
                }</span> else<span class="cov8" title="1"> {
                        for _, script := range runCfg.Task </span><span class="cov8" title="1">{
                                if strings.EqualFold(target, script.ID) </span><span class="cov8" title="1">{
                                        taskList = append(taskList, script)
                                }</span>
                        }
                }

                // check if we have found the target
                <span class="cov8" title="1">for curTIndex, script := range taskList </span><span class="cov8" title="1">{
                        if strings.EqualFold(target, script.ID) </span><span class="cov8" title="1">{
                                GetLogger().WithFields(logrus.Fields{
                                        "target":    target,
                                        "scopeVars": scopeVars,
                                }).Info("executeTemplate EXECUTE target")
                                targetFound = true

                                stopReason := script.Stopreasons

                                var messageCmdCtrl CtxOutCtrl = CtxOutCtrl{ // define a controll hook, depending on the display comand option
                                        IgnoreCase: !script.Options.Displaycmd, // we ignore thie message, as long the display command is NOT set
                                }

                                // check requirements
                                canRun, message := checkRequirements(script.Requires)
                                if !canRun </span><span class="cov8" title="1">{
                                        GetLogger().WithFields(logrus.Fields{
                                                "target": target,
                                                "reason": message,
                                        }).Info("executeTemplate IGNORE because requirements not matching")
                                        if script.Options.Displaycmd </span><span class="cov0" title="0">{
                                                CtxOut(messageCmdCtrl, LabelFY("require"), ValF(message), InfoF("Task-Block "), curTIndex+1, " of ", len(taskList), " skipped")
                                        }</span>
                                        // ---- return ExitByRequirement
                                        <span class="cov8" title="1">continue</span>
                                }

                                // get the task related variables
                                <span class="cov8" title="1">for keyName, variable := range script.Variables </span><span class="cov8" title="1">{
                                        SetPH(keyName, HandlePlaceHolder(variable))
                                        scopeVars[keyName] = variable
                                }</span>
                                <span class="cov8" title="1">backToDir := ""
                                // if working dir is set change to them
                                if script.Options.WorkingDir != "" </span><span class="cov8" title="1">{
                                        backToDir, _ = dirhandle.Current()
                                        chDirError := os.Chdir(HandlePlaceHolderWithScope(script.Options.WorkingDir, scopeVars))
                                        if chDirError != nil </span><span class="cov0" title="0">{
                                                manout.Error("Workspace setting seems invalid ", chDirError)
                                                systools.Exit(10)
                                        }</span>
                                }

                                // just the abort flag.
                                <span class="cov8" title="1">abort := false

                                // experimental usage of needs
                                if Experimental </span><span class="cov8" title="1">{
                                        // -- NEEDS
                                        // needs are task, the have to be startet once
                                        // before we continue.
                                        // any need can have his own needs they needs to
                                        // be executed
                                        if len(script.Needs) &gt; 0 </span><span class="cov8" title="1">{

                                                CtxOut(messageCmdCtrl, LabelFY("target"), ValF(target), InfoF("require"), ValF(len(script.Needs)), InfoF("needs. async?"), ValF(runAsync))
                                                GetLogger().WithField("needs", script.Needs).Debug("Needs for the script")
                                                if runAsync </span><span class="cov8" title="1">{
                                                        var needExecs []awaitgroup.FutureStack
                                                        for _, needTarget := range script.Needs </span><span class="cov8" title="1">{
                                                                if TaskRunsAtLeast(needTarget, 1) </span><span class="cov8" title="1">{
                                                                        CtxOut(messageCmdCtrl, LabelFY("need check"), ValF(target), InfoRed("already executed"), ValF(needTarget))
                                                                        GetLogger().Debug("need already handled " + needTarget)
                                                                }</span> else<span class="cov8" title="1"> {
                                                                        GetLogger().Debug("need name should be added " + needTarget)
                                                                        CtxOut(messageCmdCtrl, LabelFY("need check"), ValF(target), InfoF("executing"), ValF(needTarget))
                                                                        needExecs = append(needExecs, awaitgroup.FutureStack{
                                                                                AwaitFunc: func(ctx context.Context) interface{} </span><span class="cov8" title="1">{
                                                                                        argNeed := ctx.Value(awaitgroup.CtxKey{}).(string)
                                                                                        _, argmap := StringSplitArgs(argNeed, "arg")
                                                                                        GetLogger().Debug("add need task " + argNeed)
                                                                                        return executeTemplate(waitGroup, true, runCfg, argNeed, argmap)
                                                                                }</span>,
                                                                                Argument: needTarget})
                                                                }
                                                        }
                                                        <span class="cov8" title="1">futures := awaitgroup.ExecFutureGroup(needExecs) // create the futures and start the tasks
                                                        results := awaitgroup.WaitAtGroup(futures)       // wait until any task is executed

                                                        GetLogger().WithField("result", results).Debug("needs result")</span>
                                                } else<span class="cov0" title="0"> {
                                                        for _, needTarget := range script.Needs </span><span class="cov0" title="0">{
                                                                if TaskRunsAtLeast(needTarget, 1) </span><span class="cov0" title="0">{ // do not run needs the already runs
                                                                        GetLogger().Debug("need already handled " + needTarget)
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        _, argmap := StringSplitArgs(needTarget, "arg")
                                                                        executeTemplate(waitGroup, false, runCfg, needTarget, argmap)
                                                                }</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">CtxOut(LabelFY("target"), ValF(target), InfoF("needs done"))</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        // NONE experimental usage of needs
                                        // checking needs
                                        if len(script.Needs) &gt; 0 </span><span class="cov0" title="0">{
                                                GetLogger().WithFields(logrus.Fields{
                                                        "needs": script.Needs,
                                                }).Info("executeTemplate NEEDS found")
                                                if runAsync </span><span class="cov0" title="0">{
                                                        waitHits := 0
                                                        timeOut := script.Options.TimeoutNeeds
                                                        if timeOut &lt; 1 </span><span class="cov0" title="0">{
                                                                GetLogger().Info("No timeoutNeeds value set. using default of 300000")
                                                                timeOut = 300000 // 5 minutes in milliseconds as default
                                                        }</span> else<span class="cov0" title="0"> {
                                                                GetLogger().WithField("timeout", timeOut).Info("timeout for task " + target)
                                                        }</span>
                                                        <span class="cov0" title="0">tickTime := script.Options.TickTimeNeeds
                                                        if tickTime &lt; 1 </span><span class="cov0" title="0">{
                                                                tickTime = 1000 // 1 second as ticktime
                                                        }</span>
                                                        <span class="cov0" title="0">WaitForTasksDone(script.Needs, time.Duration(timeOut)*time.Millisecond, time.Duration(tickTime)*time.Millisecond, func() bool </span><span class="cov0" title="0">{
                                                                // still waiting
                                                                waitHits++
                                                                GetLogger().Debug("Waiting for Task be done")
                                                                return true
                                                        }</span>, func() {<span class="cov0" title="0">
                                                                // done

                                                        }</span>, func() <span class="cov0" title="0">{
                                                                // timeout not allowed. hard exit
                                                                GetLogger().Debug("timeout hit")
                                                                manout.Error("Need Timeout", "waiting for a need timed out after ", timeOut, " milliseconds. you may increase timeoutNeeds in Options")
                                                                systools.Exit(1)
                                                        }</span>, func(needTarget string, _ string, args map[string]string) bool <span class="cov0" title="0">{
                                                                if script.Options.NoAutoRunNeeds </span><span class="cov0" title="0">{
                                                                        manout.Error("Need Task not started", "expected task ", target, " not running. autostart disabled")
                                                                        systools.Exit(1)
                                                                        return false
                                                                }</span>
                                                                <span class="cov0" title="0">GetLogger().WithFields(logrus.Fields{
                                                                        "needs":   script.Needs,
                                                                        "current": needTarget,
                                                                }).Info("executeTemplate found a need that is not stated already")
                                                                // stopping for a couple of time
                                                                // need to wait if these other task already started by
                                                                // other options
                                                                time.Sleep(500 * time.Millisecond)
                                                                go executeTemplate(waitGroup, runAsync, runCfg, needTarget, args)
                                                                return true</span>
                                                        })
                                                } else<span class="cov0" title="0"> {
                                                        // run needs in a sequence
                                                        for _, targetNeed := range script.Needs </span><span class="cov0" title="0">{
                                                                var args map[string]string = make(map[string]string) // no supported usage right now
                                                                executionCode := executeTemplate(waitGroup, runAsync, runCfg, targetNeed, args)
                                                                if executionCode != ExitOk </span><span class="cov0" title="0">{
                                                                        manout.Error("Need Task Error", "expected returncode ", ExitOk, " but got exit Code", executionCode)
                                                                        systools.Exit(1)
                                                                }</span>
                                                        }
                                                }
                                        }
                                } // end of experimental switch

                                // targets that should be started as well
                                // these targets running at the same time
                                // so different to scope, we dont need to wait
                                // right now until they ends
                                <span class="cov8" title="1">var runTargetfutures []awaitgroup.Future
                                if Experimental </span><span class="cov8" title="1">{
                                        runTargetfutures = generateFuturesByTargetListAndExec(script.RunTargets, waitGroup, runCfg)
                                }</span> else<span class="cov0" title="0"> {
                                        if len(script.RunTargets) &gt; 0 </span><span class="cov0" title="0">{
                                                for _, runTrgt := range script.RunTargets </span><span class="cov0" title="0">{
                                                        if runAsync </span><span class="cov0" title="0">{
                                                                go executeTemplate(waitGroup, runAsync, runCfg, runTrgt, scopeVars)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                executeTemplate(waitGroup, runAsync, runCfg, runTrgt, scopeVars)
                                                        }</span>
                                                }
                                                // workaround til the async runnig is refactored
                                                // now we need to give the subtask time to run and update the waitgroup
                                                <span class="cov0" title="0">duration := time.Second
                                                time.Sleep(duration)</span>
                                        }
                                }

                                // check if we have script lines.
                                // if not, we need at least to check
                                // 'now' listener
                                <span class="cov8" title="1">if len(script.Script) &lt; 1 </span><span class="cov8" title="1">{
                                        GetLogger().Debug("no script lines defined. run listener anyway")
                                        listenerWatch(script, target, "", nil, waitGroup, runAsync, runCfg)
                                        // workaround til the async runnig is refactored
                                        // now we need to give the subtask time to run and update the waitgroup
                                        duration := time.Second
                                        time.Sleep(duration)
                                }</span>

                                // preparing codelines by execute second level commands
                                // that can affect the whole script
                                <span class="cov8" title="1">abort, returnCode, _ = TryParse(script.Script, func(codeLine string) (bool, int) </span><span class="cov8" title="1">{
                                        lineAbort, lineExitCode := lineExecuter(waitGroup, runAsync, stopReason, runCfg, colorCode, bgCode, codeLine, target, scopeVars, script)
                                        return lineExitCode, lineAbort
                                }</span>)
                                <span class="cov8" title="1">if abort </span><span class="cov8" title="1">{
                                        GetLogger().Debug("abort reason found ")
                                }</span>

                                // waitin until the any target that runns also is done
                                <span class="cov8" title="1">if Experimental &amp;&amp; len(runTargetfutures) &gt; 0 </span><span class="cov8" title="1">{
                                        CtxOut(messageCmdCtrl, LabelFY("wait targets"), "waiting until beside running targets are done")
                                        trgtRes := awaitgroup.WaitAtGroup(runTargetfutures)
                                        CtxOut(messageCmdCtrl, LabelFY("wait targets"), "waiting done", trgtRes)
                                }</span>
                                // next are tarets they runs afterwards the regular
                                // script os done
                                <span class="cov8" title="1">GetLogger().WithFields(logrus.Fields{
                                        "current-target": target,
                                        "nexts":          script.Next,
                                }).Debug("executeTemplate next definition")
                                if Experimental </span><span class="cov8" title="1">{
                                        nextfutures := generateFuturesByTargetListAndExec(script.Next, waitGroup, runCfg)
                                        nextRes := awaitgroup.WaitAtGroup(nextfutures)
                                        CtxOut(messageCmdCtrl, LabelFY("wait next"), "waiting done", nextRes)

                                }</span> else<span class="cov0" title="0"> {
                                        for _, nextTarget := range script.Next </span><span class="cov0" title="0">{
                                                if script.Options.Displaycmd </span><span class="cov0" title="0">{
                                                        CtxOut(LabelFY("next"), InfoF(nextTarget))
                                                }</span>
                                                /* ---- something is wrong with my logic dependig execution not in a sequence (useWaitGroup == true)
                                                if useWaitGroup {
                                                        go executeTemplate(waitGroup, useWaitGroup, runCfg, nextTarget)

                                                } else {
                                                        executeTemplate(waitGroup, useWaitGroup, runCfg, nextTarget)
                                                }*/

                                                // for now we execute without a waitgroup
                                                <span class="cov0" title="0">executeTemplate(waitGroup, runAsync, runCfg, nextTarget, scopeVars)</span>
                                        }
                                }

                                //return returnCode
                                // back to old dir if workpace usage was set
                                <span class="cov8" title="1">if backToDir != "" </span><span class="cov8" title="1">{
                                        os.Chdir(backToDir)
                                }</span>
                        }

                }
                <span class="cov8" title="1">if !targetFound </span><span class="cov8" title="1">{
                        CtxOut(manout.MessageCln(manout.ForeYellow, "target not defined: ", manout.ForeWhite, target))
                        GetLogger().Error("Target can not be found: ", target)
                }</span>

                <span class="cov8" title="1">GetLogger().WithFields(logrus.Fields{
                        "target": target,
                }).Info("executeTemplate. target do not contains tasks")
                return returnCode</span>
        }
        <span class="cov0" title="0">return ExitNoCode</span>
}

func defaultString(line string, defaultString string) string <span class="cov8" title="1">{
        if line == "" </span><span class="cov8" title="1">{
                return defaultString
        }</span>
        <span class="cov0" title="0">return line</span>
}

func handleFileImportsToVars(imports []string) <span class="cov8" title="1">{
        for _, filenameFull := range imports </span><span class="cov8" title="1">{
                var keyname string
                parts := strings.Split(filenameFull, " ")
                filename := parts[0]
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        keyname = parts[1]
                }</span>

                <span class="cov8" title="1">dirhandle.FileTypeHandler(filename, func(jsonBaseName string) </span><span class="cov0" title="0">{
                        GetLogger().Debug("loading json File as second level variables:", filename)
                        if keyname == "" </span><span class="cov0" title="0">{
                                keyname = jsonBaseName
                        }</span>
                        <span class="cov0" title="0">ImportDataFromJSONFile(keyname, filename)</span>

                }, func(yamlBaseName string) <span class="cov8" title="1">{
                        GetLogger().Debug("loading yaml File: as second level variables", filename)
                        if keyname == "" </span><span class="cov8" title="1">{
                                keyname = yamlBaseName
                        }</span>
                        <span class="cov8" title="1">ImportDataFromYAMLFile(keyname, filename)</span>

                }, func(path string, err error) <span class="cov0" title="0">{
                        GetLogger().Errorln("file not exists:", err)
                        manout.Error("varibales file not exists:", path, err)
                        systools.Exit(1)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "bufio"
        "fmt"
        "io/ioutil"
        "os"
        "os/exec"
        "strings"
        "sync"
        "syscall"

        "github.com/sirupsen/logrus"
        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/dirhandle"
)

const (
        // DefaultExecFile is the filename of the script defaut file
        DefaultExecFile = string(os.PathSeparator) + ".context.json"

        // DefaultExecYaml is the default yaml configuration file
        DefaultExecYaml     = string(os.PathSeparator) + ".contxt.yml"
        defaultExecYamlName = ".contxt.yml"

        // TargetScript is script default target
        TargetScript = "script"

        // InitScript is script default target
        InitScript = "init"

        // ClearScript is script default target
        ClearScript = "clear"

        // TestScript is teh test target
        TestScript = "test"

        // DefaultCommandFallBack is used if no command is defined
        DefaultCommandFallBack = "bash"

        // On windows we have a different default
        DefaultCommandFallBackWindows = "powershell"
)

// ExecuteTemplateWorker runs ExecCurrentPathTemplate in context of a waitgroup
func ExecuteTemplateWorker(waitGroup *sync.WaitGroup, useWaitGroup bool, target string, template configure.RunConfig) <span class="cov0" title="0">{
        if useWaitGroup </span><span class="cov0" title="0">{
                defer waitGroup.Done()
        }</span>
        //ExecCurrentPathTemplate(path)
        <span class="cov0" title="0">exitCode := ExecPathFile(waitGroup, useWaitGroup, template, target)
        GetLogger().WithField("exitcode", exitCode).Info("ExecuteTemplateWorker done with exitcode")</span>

}

func GetExecDefaults() (string, []string) <span class="cov8" title="1">{
        cmd := GetDefaultCmd()
        var args []string
        args = GetDefaultCmdOpts(cmd, args)
        return cmd, args
}</span>

func GetDefaultCmd() string <span class="cov8" title="1">{

        envCmd := os.Getenv("CTX_DEFAULT_CMD")
        if envCmd != "" </span><span class="cov0" title="0">{
                GetLogger().WithField("defaultcmd", envCmd).Info("Got default cmd from environment")
                return envCmd
        }</span>

        <span class="cov8" title="1">if configure.GetOs() == "windows" </span><span class="cov0" title="0">{
                return DefaultCommandFallBackWindows
        }</span>
        <span class="cov8" title="1">return DefaultCommandFallBack</span>
}

func GetDefaultCmdOpts(ShellToUse string, cmdArg []string) []string <span class="cov8" title="1">{
        if configure.GetOs() == "windows" </span><span class="cov0" title="0">{
                if envCmd := os.Getenv("CTX_DEFAULT_CMD_ARGUMENTS"); envCmd != "" </span><span class="cov0" title="0">{
                        GetLogger().WithField("arguments", envCmd).Info("Got cmd arguments form environment")
                        return strings.Split(envCmd, " ")
                }</span>
                <span class="cov0" title="0">if cmdArg == nil &amp;&amp; ShellToUse == DefaultCommandFallBackWindows </span><span class="cov0" title="0">{
                        cmdArg = []string{"-nologo", "-noprofile"}
                }</span>
        } else<span class="cov8" title="1"> {
                if cmdArg == nil &amp;&amp; ShellToUse == DefaultCommandFallBack </span><span class="cov8" title="1">{
                        cmdArg = []string{"-c"}
                }</span>
        }
        <span class="cov8" title="1">return cmdArg</span>
}

// ExecuteScriptLine executes a simple shell script
// returns internal exitsCode, process existcode, error
func ExecuteScriptLine(ShellToUse string, cmdArg []string, command string, callback func(string, error) bool, startInfo func(*os.Process)) (int, int, error) <span class="cov8" title="1">{
        cmdArg = GetDefaultCmdOpts(ShellToUse, cmdArg)
        cmdArg = append(cmdArg, command)
        cmd := exec.Command(ShellToUse, cmdArg...)
        stdoutPipe, _ := cmd.StdoutPipe()
        cmd.Stderr = cmd.Stdout

        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                GetLogger().Warn("execution error: ", err)
                return ExitCmdError, 0, err
        }</span>

        <span class="cov8" title="1">GetLogger().WithFields(logrus.Fields{
                "env":        cmd.Env,
                "args":       cmd.Args,
                "dir":        cmd.Dir,
                "extrafiles": cmd.ExtraFiles,
                "pid":        cmd.Process.Pid,
        }).Info(":::EXEC")

        startInfo(cmd.Process)
        scanner := bufio.NewScanner(stdoutPipe)

        scanner.Split(bufio.ScanLines)
        for scanner.Scan() </span><span class="cov8" title="1">{
                m := scanner.Text()

                keepRunning := callback(m, nil)

                GetLogger().WithFields(logrus.Fields{
                        "keep-running": keepRunning,
                        "out":          m,
                }).Info("handle-result")
                if !keepRunning </span><span class="cov8" title="1">{
                        cmd.Process.Kill()
                        return ExitByStopReason, 0, err
                }</span>

        }
        <span class="cov8" title="1">err = cmd.Wait()
        if err != nil </span><span class="cov8" title="1">{
                callback(err.Error(), err)
                errRealCode := 0
                if exiterr, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                        if status, ok := exiterr.Sys().(syscall.WaitStatus); ok </span><span class="cov8" title="1">{
                                GetLogger().Warn("(maybe expected...) Exit Status reported: ", status.ExitStatus())
                                errRealCode = status.ExitStatus()
                        }</span>

                } else<span class="cov0" title="0"> {
                        GetLogger().Warn("execution error: ", err)
                }</span>
                <span class="cov8" title="1">return ExitCmdError, errRealCode, err</span>
        }

        <span class="cov8" title="1">return ExitOk, 0, err</span>
}

// WriteTemplate create path based execution file
func WriteTemplate() <span class="cov0" title="0">{
        dir, error := dirhandle.Current()
        if error != nil </span><span class="cov0" title="0">{
                fmt.Println("error getting current directory")
                return
        }</span>

        <span class="cov0" title="0">var path = dir + DefaultExecYaml
        already, errEx := dirhandle.Exists(path)
        if errEx != nil </span><span class="cov0" title="0">{
                fmt.Println("error ", errEx)
                return
        }</span>

        <span class="cov0" title="0">if already </span><span class="cov0" title="0">{
                fmt.Println("file already exists.", path, " aborted")
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("write execution template to ", path)

        var demoContent = `task:
  - id: script
    script:
      - echo "hello world"
`
        err := ioutil.WriteFile(path, []byte(demoContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
}

// ExecPathFile executes the default exec file
func ExecPathFile(waitGroup *sync.WaitGroup, useWaitGroup bool, template configure.RunConfig, target string) int <span class="cov8" title="1">{
        var scopeVars map[string]string = make(map[string]string)
        return executeTemplate(waitGroup, useWaitGroup, template, target, scopeVars)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "errors"
        "strings"
)

func ExportTask(target string) (string, error) <span class="cov8" title="1">{
        template, _, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                return "", terr
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return "", errors.New("template not exists")
        }</span>
        <span class="cov8" title="1">var out string = ""
        for _, task := range template.Task </span><span class="cov8" title="1">{
                if task.ID == target </span><span class="cov8" title="1">{
                        if canRun, message := checkRequirements(task.Requires); canRun </span><span class="cov8" title="1">{
                                for _, need := range task.Needs </span><span class="cov0" title="0">{
                                        out = out + "\n# --- target " + need + " included ---- this is a need of " + target + "\n\n"
                                        if needtask, nErr := ExportTask(need); nErr == nil </span><span class="cov0" title="0">{
                                                out = out + needtask + "\n"
                                        }</span>
                                }
                                <span class="cov8" title="1">out = out + strings.Join(task.Script, "\n") + "\n"
                                for _, next := range task.Next </span><span class="cov0" title="0">{
                                        out = out + "\n# --- target " + next + " included ---- this is a next-task of " + target + "\n\n"
                                        if nextJob, sErr := ExportTask(next); sErr == nil </span><span class="cov0" title="0">{
                                                out = out + nextJob + "\n"
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                out = out + "\n# --- -----------------------------------------------------------------------------------  ---- \n"
                                out = out + "# --- a  sequence of the target " + target + " is ignored because of a failed requirement  ---- \n"
                                out = out + "# --- this is might be an usual case. The reported reason to skip: " + message + "  \n"
                                out = out + "# --- -----------------------------------------------------------------------------------  ---- \n"
                        }</span>
                }
        }
        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package taskrun

import (
        "fmt"
        "os"
        "strconv"

        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
        "github.com/spf13/cobra"
        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/dirhandle"
        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"
)

type CtxUi struct {
        title          string
        app            *tview.Application
        pages          *tview.Pages
        menu           *tview.List
        cmd            *cobra.Command
        outscr         *tview.TextView
        args           []string
        LogOutMessage  string
        mainScr        *tview.TextView
        statusScr      *tview.TextView
        taskScr        *tview.TextView
        selectedtarget string
        targetCtrl     *tview.Form
        targetList     *tview.List
        wsList         *tview.List
        pathList       *tview.List
}

func InitWindow(cmd *cobra.Command, args []string) (*CtxUi, error) <span class="cov0" title="0">{
        app := tview.NewApplication()
        pages := tview.NewPages()
        ui := &amp;CtxUi{
                title: "con.txt",
                app:   app,
                pages: pages,
                cmd:   cmd,
                args:  args,
        }
        // the main window

        // create the main menu
        menu := ui.createMenu()
        menu.SetBorder(true)

        status := tview.NewTextView()
        status.SetText(ui.createStautsText())
        status.SetBorder(true)
        status.SetDynamicColors(true)
        ui.statusScr = status

        mainWindow := tview.NewTextView()
        mainWindow.SetBorder(true)
        mainWindow.SetDynamicColors(true)

        ui.mainScr = mainWindow

        flex := tview.NewFlex().
                AddItem(menu, 0, 1, true).
                AddItem(tview.NewFlex().SetDirection(tview.FlexRow).
                        AddItem(status, 0, 1, false).
                        AddItem(mainWindow, 0, 5, false), 0, 3, false)

        pages.AddPage("main", flex, true, true)

        stat := ui.createHeaderText()

        frame := tview.NewFrame(pages)
        frame.SetBorders(1, 1, 1, 1, 0, 0).
                AddText(stat, true, tview.AlignCenter, tcell.ColorWhite).
                AddText(configure.GetVersion()+" "+configure.GetBuild()+" "+configure.GetOs(), false, tview.AlignCenter, tcell.ColorWhite)

        frame.SetBackgroundColor(tcell.ColorGray)

        // define the root element
        app.SetRoot(frame, true).EnableMouse(true)

        ui.startCapture()
        // register exist trigger to get the app closed before
        systools.AddExitListener("interactive", func(exitCode int) systools.ExitBehavior </span><span class="cov0" title="0">{
                app.Stop()
                return systools.Continue
        }</span>)
        <span class="cov0" title="0">if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                return ui, err
        }</span>

        <span class="cov0" title="0">return ui, nil</span>
}

func (ui *CtxUi) createHeaderText() string <span class="cov0" title="0">{
        path := ""
        if configure.UsedConfig.LastIndex &lt; len(configure.UsedConfig.Paths) </span><span class="cov0" title="0">{
                path = configure.UsedConfig.Paths[configure.UsedConfig.LastIndex]

                dir, err := dirhandle.Current()
                if err != nil </span><span class="cov0" title="0">{
                        return "[red]" + err.Error()
                }</span>

                <span class="cov0" title="0">if dir != path </span><span class="cov0" title="0">{
                        path = "[red]" + path + "[white](we are not in this path)"
                }</span>
        }
        <span class="cov0" title="0">header := "[blue]WORKSPACE [yellow]" + configure.UsedConfig.CurrentSet + " [blue]current active dir[yellow] " + path
        return header</span>
}

func (ui *CtxUi) createStautsText() string <span class="cov0" title="0">{
        template, path, exists, err := GetTemplate()
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return "[yellow]no template in this location."
        }</span>

        <span class="cov0" title="0">status := "[blue]path [yellow]" + path + " [blue]version[yellow] " + template.Version
        return status</span>
}

func (ui *CtxUi) UpdateAll() {<span class="cov0" title="0">

}</span>

func (ui *CtxUi) UpdatePathList() <span class="cov0" title="0">{
        ui.pathList.Clear()
        ui.pathList.AddItem("[blue]&lt;&lt;&lt; [green]BACK", "", 'x', func() </span><span class="cov0" title="0">{
                ui.pages.SendToBack("paths")
        }</span>)

        <span class="cov0" title="0">configure.PathWorker(func(index int, name string) </span><span class="cov0" title="0">{
                indxStr := strconv.Itoa(index)
                ui.pathList.AddItem(name, "", rune(indxStr[0]), nil)
        }</span>)
}

// createMenu creates the main menu as a default tview.List
func (ui *CtxUi) createMenu() *tview.List <span class="cov0" title="0">{

        menu := tview.NewList().AddItem("Task", "task in the current path", 't', func() </span><span class="cov0" title="0">{
                ui.pages.SendToFront("target")
        }</span>).AddItem("Workspaces", "change workspaces", 'w', func() <span class="cov0" title="0">{
                ui.pages.SendToFront("workspace")
        }</span>).AddItem("Paths", "change to path in workspace", 'w', func() <span class="cov0" title="0">{
                ui.pages.SendToFront("paths")
        }</span>).AddItem("quit", "exit this application", 'q', func() <span class="cov0" title="0">{
                ui.app.Stop()
        }</span>)
        <span class="cov0" title="0">ui.pages.AddPage("target", ui.CreateRunPage(), true, true)
        ui.pages.AddPage("workspace", ui.CreateWorkSpacePage(), true, true)
        ui.pages.AddPage("paths", ui.CreatePathSelectPage(), true, true)
        //CreatePathSelectPage
        menu.SetHighlightFullLine(true)
        ui.menu = menu
        return menu</span>
}

// FilterOutPut parses the content and handles
// all interface depending the Type differently
func (ui *CtxUi) FilterOutPut(caseHandle func(target string, msg []interface{}), msg ...interface{}) []interface{} <span class="cov0" title="0">{
        var newMsh []interface{} // new hash for the output
        haveTarget := ""
        for _, chk := range msg </span><span class="cov0" title="0">{
                switch v := chk.(type) </span>{
                case CtxOutCtrl:<span class="cov0" title="0">
                        if chk.(CtxOutCtrl).IgnoreCase </span><span class="cov0" title="0">{ // if we have found this flag set to true, it means ignore the message
                                return newMsh
                        }</span>
                        <span class="cov0" title="0">continue</span>
                case CtxOutLabel:<span class="cov0" title="0">
                        newMsh = append(newMsh, manout.Message(v.Message))
                        continue</span>
                case CtxTargetOut:<span class="cov0" title="0">
                        haveTarget = v.Target
                        newMsh = append(newMsh, v.Target)</span>
                default:<span class="cov0" title="0">
                        newMsh = append(newMsh, chk)</span>
                }

        }
        <span class="cov0" title="0">if haveTarget != "" </span><span class="cov0" title="0">{
                caseHandle(haveTarget, newMsh)
                var dwMsh []interface{}
                return dwMsh
        }</span>
        <span class="cov0" title="0">return newMsh</span>
}

// startCapture set up the output capturing.
// it is also the method that is the "tick"
// because it will be triggered on statusmessage
// So this is the place to update all components
func (ui *CtxUi) startCapture() <span class="cov0" title="0">{
        // we set the PreHook so any Message that is send to
        // CtxOut will be handled from now on by this function
        PreHook = func(msg ...interface{}) bool </span><span class="cov0" title="0">{
                msg = ui.FilterOutPut(func(target string, msg []interface{}) </span><span class="cov0" title="0">{
                        if ui.outscr != nil </span><span class="cov0" title="0">{
                                byte4main := []byte(tview.TranslateANSI(fmt.Sprintln(msg...)))
                                ui.outscr.Write(byte4main)
                        }</span>
                }, msg...) // filter output depending types of the content

                <span class="cov0" title="0">if len(msg) &gt; 0 &amp;&amp; ui.mainScr != nil </span><span class="cov0" title="0">{
                        byteData := []byte(tview.TranslateANSI(fmt.Sprintln(msg...)))
                        ui.mainScr.Write(byteData)

                        if ui.outscr != nil </span><span class="cov0" title="0">{
                                byte4main := []byte(tview.TranslateANSI(fmt.Sprintln(msg...)))
                                ui.outscr.Write(byte4main)
                        }</span>
                }

                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">CtxOut("running target")</span>
}

func (ui *CtxUi) updateTaskView() <span class="cov0" title="0">{
        if ui.selectedtarget != "" &amp;&amp; ui.taskScr != nil </span><span class="cov0" title="0">{
                ui.taskScr.SetText(ui.selectedtarget)

        }</span>

        <span class="cov0" title="0">if ui.targetCtrl != nil </span><span class="cov0" title="0">{
                ui.targetCtrl.Clear(true)
                if ui.selectedtarget != "" </span><span class="cov0" title="0">{
                        ui.targetCtrl.AddButton("Start "+ui.selectedtarget, func() </span><span class="cov0" title="0">{
                                go RunTargets(ui.selectedtarget, true)
                        }</span>)
                }
        }
}

func (ui *CtxUi) CreateWorkSpacePage() *tview.Flex <span class="cov0" title="0">{

        uiWsList := tview.NewList()
        uiWsList.AddItem("[blue]&lt;&lt;&lt; [green]BACK", "", 'x', func() </span><span class="cov0" title="0">{
                ui.pages.SendToBack("workspace")
        }</span>)
        <span class="cov0" title="0">configure.WorkSpaces(func(name string) </span><span class="cov0" title="0">{
                uiWsList.AddItem(name, "", rune(name[0]), nil)
        }</span>)
        <span class="cov0" title="0">uiWsList.SetHighlightFullLine(true)
        uiWsList.ShowSecondaryText(false)
        uiWsList.SetSelectedFunc(func(i int, s1, s2 string, r rune) </span><span class="cov0" title="0">{
                doMagicParamOne(s1)
                ui.UpdateAll()
                ui.pages.SendToBack("workspace")
                ui.updateTaskView()
        }</span>)
        <span class="cov0" title="0">wsflex := tview.NewFlex().AddItem(uiWsList, 0, 1, true)
        return wsflex</span>
}

func (ui *CtxUi) CreatePathSelectPage() *tview.Flex <span class="cov0" title="0">{

        ui.pathList = tview.NewList()
        ui.UpdatePathList()
        ui.pathList.SetHighlightFullLine(true)
        ui.pathList.ShowSecondaryText(false)
        ui.pathList.SetSelectedFunc(func(i int, s1, s2 string, r rune) </span><span class="cov0" title="0">{
                //doMagicParamOne(s1)

                configure.PathWorker(func(index int, path string) </span><span class="cov0" title="0">{
                        if path == s1 </span><span class="cov0" title="0">{
                                configure.UsedConfig.LastIndex = index
                                configure.SaveDefaultConfiguration(true)
                                os.Chdir(path)
                        }</span>
                })
                <span class="cov0" title="0">ui.pages.SendToBack("paths")</span>
        })
        <span class="cov0" title="0">wsflex := tview.NewFlex().AddItem(ui.pathList, 0, 1, true)
        return wsflex</span>
}

// CreateRunPage builds the page that contains different elements
// to inspect and run the targets
func (ui *CtxUi) CreateRunPage() *tview.Flex <span class="cov0" title="0">{
        // this uiTaskList contains any target and we use them as a menu

        uiTaskList := tview.NewList()
        uiTaskList.AddItem("[blue]&lt;&lt;&lt; [green]BACK", "", 'x', func() </span><span class="cov0" title="0">{
                ui.pages.SendToBack("target")
        }</span>)
        <span class="cov0" title="0">var keyList string = "abcdefghijklmnopqrstuvwyz1234567890" // shortcuts definition
        if targets, ok := GetAllTargets(); ok </span><span class="cov0" title="0">{                    // get all targets
                for index, target := range targets </span><span class="cov0" title="0">{
                        if index &lt;= len(keyList) </span><span class="cov0" title="0">{ // we just print targets until we have chars to map
                                uiTaskList.AddItem(target, "", rune(keyList[index]), nil) // add the target as listitem
                        }</span>
                }
        }
        <span class="cov0" title="0">uiTaskList.SetHighlightFullLine(true)
        uiTaskList.SetSelectedFunc(func(i int, target, s2 string, r rune) </span><span class="cov0" title="0">{
                if r != 'x' </span><span class="cov0" title="0">{ // we ignore the get-back button
                        if ui.outscr != nil </span><span class="cov0" title="0">{
                                ui.outscr.Clear()
                        }</span>
                        <span class="cov0" title="0">ui.selectedtarget = target
                        go RunTargets(target, true)</span>
                } else<span class="cov0" title="0"> {
                        ui.selectedtarget = ""
                }</span>
        })

        <span class="cov0" title="0">uiTaskList.SetBorder(true)
        uiTaskList.SetTitle("select target")
        uiTaskList.ShowSecondaryText(false)
        uiTaskList.SetChangedFunc(func(index int, target, emptyAnyway string, shortcut rune) </span><span class="cov0" title="0">{
                if shortcut != 'x' </span><span class="cov0" title="0">{ // ignore get back option
                        ui.selectedtarget = target
                        ui.updateTaskView()
                }</span>
        })

        // create the log output
        <span class="cov0" title="0">output := tview.NewTextView().
                SetDynamicColors(true).
                SetChangedFunc(func() </span><span class="cov0" title="0">{
                        ui.app.Draw()
                }</span>)
        <span class="cov0" title="0">output.SetBorder(true).SetTitle("log")
        ui.outscr = output

        // create a target overview
        targetControl := tview.NewForm()
        targetControl.SetBorder(true)
        ui.targetCtrl = targetControl

        // left side we have the list of task
        // and the form that we use to start a task
        leftCtrl := tview.NewFlex().SetDirection(tview.FlexRow)
        leftCtrl.AddItem(uiTaskList, 0, 6, true).
                AddItem(targetControl, 0, 1, false)
        // this is the task overview where
        // we display the current status of the task
        targetView := tview.NewTextView()
        targetView.SetDynamicColors(true).SetBorder(true)
        ui.taskScr = targetView

        // the right site of the page contains
        // the target overview and the log output
        rightCtrl := tview.NewFlex().SetDirection(tview.FlexRow)
        rightCtrl.AddItem(targetView, 0, 1, false).
                AddItem(output, 0, 1, false)

        // compose the page content
        targetflex := tview.NewFlex().
                AddItem(leftCtrl, 0, 1, true).
                AddItem(rightCtrl, 0, 4, false)
        return targetflex</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package taskrun

import (
        "fmt"

        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"
)

var PreHook func(msg ...interface{}) bool = nil

type CtxOutCtrl struct {
        IgnoreCase bool
}

type CtxOutLabel struct {
        Message interface{}
        FColor  string
}

type CtxTargetOut struct {
        ForeCol     string
        BackCol     string
        SplitLabel  string
        Target      string
        Alternative string
        PanelSize   int
}

func CtxOut(msg ...interface{}) <span class="cov8" title="1">{
        if PreHook != nil </span><span class="cov0" title="0">{ // if the prehook is defined AND it returns true, we just stop doing anything
                if abort := PreHook(msg...); abort </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">var newMsh []interface{}
        for _, chk := range msg </span><span class="cov8" title="1">{
                switch ctrl := chk.(type) </span>{
                case CtxOutCtrl:<span class="cov8" title="1">
                        if chk.(CtxOutCtrl).IgnoreCase </span><span class="cov8" title="1">{ // if we have found this flag set to true, it means ignore the message
                                return
                        }</span>
                case CtxTargetOut:<span class="cov8" title="1">
                        labelStr := systools.LabelPrintWithArg(systools.PadStringToR(ctrl.Target, ctrl.PanelSize), ctrl.ForeCol, ctrl.BackCol, 1)
                        newMsh = append(newMsh, labelStr)</span>
                case CtxOutLabel:<span class="cov8" title="1">
                        colmsg := manout.Message(ctrl.FColor, ctrl.Message) + " "
                        newMsh = append(newMsh, colmsg)</span>
                default:<span class="cov8" title="1">
                        newMsh = append(newMsh, chk)</span>
                }

        }
        <span class="cov8" title="1">msg = newMsh
        /*fmt.Print(manout.MessageCln(

        manout.BackDarkGrey, "c",
        manout.BackWhite, manout.ForeBlue,
        "on", manout.ForeDarkGrey, ".", manout.ForeMagenta, "tx",
        manout.BackDarkGrey, "t",
        manout.CleanTag, " "))*/
        fmt.Println(manout.MessageCln(msg...))</span>
}

func ValF(val interface{}) CtxOutLabel <span class="cov8" title="1">{
        return CtxOutLabel{Message: val, FColor: manout.ForeLightBlue}
}</span>

func InfoF(val interface{}) CtxOutLabel <span class="cov8" title="1">{
        return CtxOutLabel{Message: val, FColor: manout.ForeCyan}
}</span>

func InfoRed(val interface{}) CtxOutLabel <span class="cov8" title="1">{
        return CtxOutLabel{Message: val, FColor: manout.ForeLightRed}
}</span>

func InfoMinor(val interface{}) CtxOutLabel <span class="cov8" title="1">{
        return CtxOutLabel{Message: val, FColor: manout.ForeDarkGrey}
}</span>

func defaultLabel(val interface{}) string <span class="cov8" title="1">{
        return fmt.Sprintf(" %10s", val)
}</span>

func LabelFY(val interface{}) CtxOutLabel <span class="cov8" title="1">{
        ctxl := CtxOutLabel{Message: val, FColor: manout.ForeYellow}
        ctxl.Message = manout.Message("[", manout.ForeYellow, defaultLabel(val), manout.ForeLightYellow, "] ")
        return ctxl
}</span>

func LabelOkF(val interface{}) CtxOutLabel <span class="cov0" title="0">{
        ctxl := CtxOutLabel{Message: val, FColor: manout.ForeLightGreen}
        ctxl.Message = manout.Message("[", manout.ForeYellow, defaultLabel(val), manout.ForeLightYellow, "] ")
        return ctxl
}</span>

func LabelErrF(val interface{}) CtxOutLabel <span class="cov8" title="1">{
        ctxl := CtxOutLabel{Message: val, FColor: manout.ForeRed}
        ctxl.Message = manout.Message("[", manout.ForeYellow, defaultLabel(val), manout.ForeLightYellow, "] ")
        return ctxl
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "bytes"
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/kylelemons/godebug/pretty"
        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"
        "gopkg.in/yaml.v3"
)

func compareContent(a, b interface{}, showBooth bool, size int, right int, noOut bool) bool <span class="cov0" title="0">{
        diffOut := pretty.Compare(a, b)
        diffParts := strings.Split(diffOut, "\n")
        var errors []string
        noDiff := true
        i := 0
        for _, line := range diffParts </span><span class="cov0" title="0">{
                backColor := manout.BackWhite
                if i%2 == 0 </span><span class="cov0" title="0">{
                        backColor = manout.BackLightGrey
                }</span>
                <span class="cov0" title="0">leftDiff := strings.HasPrefix(line, "+")
                rightDiff := strings.HasPrefix(line, "-")

                if leftDiff &amp;&amp; showBooth </span><span class="cov0" title="0">{
                        lft := getMaxLineString("", size)
                        line = getMaxLineString(line, right)
                        if !noOut </span><span class="cov0" title="0">{
                                fmt.Println(manout.MessageCln(backColor, manout.ForeYellow, manout.Dim, lft, line))
                        }</span>
                        <span class="cov0" title="0">i++</span>
                }
                <span class="cov0" title="0">if rightDiff </span><span class="cov0" title="0">{
                        errors = append(errors, "unsupported: "+line)
                        rgt := getMaxLineString("  unsupported element ", right)
                        line = getMaxLineString(line, size)
                        backColor := manout.BackYellow
                        if i%2 == 0 </span><span class="cov0" title="0">{
                                backColor = manout.BackLightYellow
                        }</span>
                        <span class="cov0" title="0">i++
                        if !noOut </span><span class="cov0" title="0">{
                                fmt.Println(manout.MessageCln(backColor, manout.BoldTag, manout.ForeDarkGrey, line, manout.ForeRed, manout.BoldTag, rgt))
                        }</span>
                }
                <span class="cov0" title="0">if !leftDiff &amp;&amp; !rightDiff </span><span class="cov0" title="0">{
                        line = getMaxLineString(line, size+right)
                        i++
                        if !noOut </span><span class="cov0" title="0">{
                                fmt.Println(manout.MessageCln(backColor, manout.ForeBlue, line))
                        }</span>
                }

        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                noDiff = false
                manout.Error("found unsupported elements.", "count of errors:", len(errors))
        }</span>

        <span class="cov0" title="0">for _, errMsg := range errors </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln(manout.ForeYellow, errMsg))
        }</span>
        <span class="cov0" title="0">return noDiff</span>
}

func trySupressDefaults(yamlString string) string <span class="cov0" title="0">{
        ln := "\n"
        outStr := ""
        // first find all defauls values
        lines := strings.Split(yamlString, ln)
        for _, line := range lines </span><span class="cov0" title="0">{
                checks := strings.Split(line, ": ")
                if len(checks) == 2 </span><span class="cov0" title="0">{
                        // these should have all possible defaults as values.
                        if checks[1] != "[]" &amp;&amp; checks[1] != "" &amp;&amp; checks[1] != "\"\"" &amp;&amp; checks[1] != "false" &amp;&amp; checks[1] != "0" </span><span class="cov0" title="0">{
                                outStr = outStr + line + ln
                        }</span>
                } else<span class="cov0" title="0"> {
                        outStr = outStr + line + ln
                }</span>
        }
        // next find empty nodes
        <span class="cov0" title="0">lines = strings.Split(outStr, ln)
        newOut := ""
        max := len(lines)
        for index, recheck := range lines </span><span class="cov0" title="0">{
                if index &gt; 0 &amp;&amp; recheck != "" </span><span class="cov0" title="0">{

                        last := recheck[len(recheck)-1:]
                        if last == ":" &amp;&amp; index &lt; max </span><span class="cov0" title="0">{
                                nextStr := lines[index+1]
                                lastNext := nextStr[len(nextStr)-1:]
                                if lastNext != ":" </span><span class="cov0" title="0">{
                                        newOut = newOut + recheck + ln
                                }</span>
                        } else<span class="cov0" title="0"> {
                                newOut = newOut + recheck + ln
                        }</span>

                } else<span class="cov0" title="0"> {
                        newOut = newOut + recheck + ln
                }</span>
        }
        <span class="cov0" title="0">return newOut</span>
}

// ShowAsYaml prints the generated source of the task file
func ShowAsYaml(fullparsed bool, trySupress bool, indent int) <span class="cov0" title="0">{
        template, path, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln(manout.ForeRed, "Error ", manout.CleanTag, terr.Error()))
                systools.Exit(33)
                return
        }</span>
        <span class="cov0" title="0">var b bytes.Buffer
        if exists </span><span class="cov0" title="0">{
                if fullparsed </span><span class="cov0" title="0">{
                        yamlEncoder := yaml.NewEncoder(&amp;b)
                        yamlEncoder.SetIndent(indent)
                        conerr := yamlEncoder.Encode(&amp;template)
                        if conerr == nil </span><span class="cov0" title="0">{
                                if trySupress </span><span class="cov0" title="0">{
                                        fmt.Println(trySupressDefaults(b.String()))
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println(b.String())
                                }</span>

                        } else<span class="cov0" title="0"> {
                                manout.Error("error parsing template", conerr)
                                systools.Exit(1)
                        }</span>

                } else<span class="cov0" title="0"> {
                        data, err := GetParsedTemplateSource(path)
                        if err != nil </span><span class="cov0" title="0">{
                                manout.Error("template loading", err)
                                systools.Exit(1)
                        }</span>
                        <span class="cov0" title="0">fmt.Println(data)</span>
                }
        }
}

func TestTemplate() error <span class="cov8" title="1">{
        if template, _, exists, terr := GetTemplate(); terr != nil </span><span class="cov0" title="0">{
                return terr
        }</span> else<span class="cov8" title="1"> {
                if !exists </span><span class="cov0" title="0">{
                        GetLogger().Debug("no template exists to check")
                }</span> else<span class="cov8" title="1"> {
                        // check version
                        // if they is not matching, we die with an error
                        if !configure.CheckCurrentVersion(template.Version) </span><span class="cov0" title="0">{
                                return errors.New("unsupported version " + template.Version)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// LintOut prints the source code and the parsed content
// in a table view, and marks configured and not configured entries
// with dfferent colors
func LintOut(leftcnt, rightcnt int, all bool, noOut bool) bool <span class="cov0" title="0">{
        template, path, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                manout.Error("ERROR", terr.Error())
                return false
        }</span>
        <span class="cov0" title="0">if exists &amp;&amp; rightcnt &gt;= 0 &amp;&amp; leftcnt &gt;= 0 </span><span class="cov0" title="0">{
                data, err := GetParsedTemplateSource(path)
                if err != nil </span><span class="cov0" title="0">{
                        manout.Error("template loading", err)
                        return false
                }</span>
                <span class="cov0" title="0">origMap, yerr := YAMLToMap(data)
                if yerr == nil </span><span class="cov0" title="0">{
                        conversionres, conerr := yaml.Marshal(template)
                        if conerr == nil </span><span class="cov0" title="0">{
                                m := make(map[string]interface{})
                                amlerr := yaml.Unmarshal(conversionres, &amp;m)
                                if amlerr != nil </span><span class="cov0" title="0">{
                                        fmt.Println(amlerr)
                                        systools.Exit(1)
                                }</span>

                                <span class="cov0" title="0">return compareContent(origMap, m, all, leftcnt, rightcnt, noOut)</span>
                        }

                } else<span class="cov0" title="0"> {
                        prinfFile(path, leftcnt+rightcnt)
                        manout.Error("parsing error", yerr)
                }</span>

        } else<span class="cov0" title="0"> {
                manout.Error("template not found ", path)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func getMaxLineString(line string, length int) string <span class="cov0" title="0">{
        if len(line) &lt; length </span><span class="cov0" title="0">{
                for i := len(line); i &lt; length; i++ </span><span class="cov0" title="0">{
                        line = line + " "
                }</span>
        }
        <span class="cov0" title="0">if len(line) &gt; length </span><span class="cov0" title="0">{
                line = line[0:length]
        }</span>
        <span class="cov0" title="0">return line</span>
}

func prinfFile(filename string, size int) error <span class="cov0" title="0">{
        data, err := GetParsedTemplateSource(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">backColor := manout.BackWhite
        lines := strings.Split(data, "\n")
        i := 0
        for _, line := range lines </span><span class="cov0" title="0">{
                i++
                prefix := getMaxLineString(strconv.Itoa(i), 5)
                line = getMaxLineString(line, size)
                fmt.Println(manout.MessageCln(manout.BackCyan, manout.ForeWhite, prefix, backColor, manout.ForeBlue, line))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package taskrun

import "os"

// CreateMirror creates nested directories
func CreateMirror(path string) <span class="cov0" title="0">{
        os.MkdirAll(path, os.ModePerm)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "fmt"
        "strings"
)

func SplitArgs(cmdList []string, prefix string, arghandler func(string, map[string]string)) []string <span class="cov8" title="1">{
        var cleared []string
        var args map[string]string = make(map[string]string)

        for _, value := range cmdList </span><span class="cov8" title="1">{
                argArr := strings.Split(value, " ")
                cleared = append(cleared, argArr[0])
                if len(argArr) &gt; 1 </span><span class="cov8" title="1">{
                        for index, v := range argArr </span><span class="cov8" title="1">{
                                args[fmt.Sprintf("%s%v", prefix, index)] = v
                        }</span>
                        <span class="cov8" title="1">arghandler(argArr[0], args)</span>
                }
        }
        <span class="cov8" title="1">return cleared</span>
}

func StringSplitArgs(argLine string, prefix string) (string, map[string]string) <span class="cov8" title="1">{
        GetLogger().WithField("args", argLine).Debug("parsing argumented string")
        var args map[string]string = make(map[string]string)
        argArr := strings.Split(argLine, " ")
        for index, v := range argArr </span><span class="cov8" title="1">{
                args[fmt.Sprintf("%s%v", prefix, index)] = v
        }</span>
        <span class="cov8" title="1">return argArr[0], args</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "os"
        "strings"
        "sync"

        "github.com/sirupsen/logrus"
)

var keyValue sync.Map

// SetPH add key value pair
func SetPH(key, value string) <span class="cov8" title="1">{
        GetLogger().WithField(key, value).Trace("add/overwrite placeholder")
        keyValue.Store(key, value)
}</span>

func AppendToPH(key, value string) bool <span class="cov8" title="1">{
        if val, ok := keyValue.Load(key); ok </span><span class="cov8" title="1">{
                value = val.(string) + value
                keyValue.Store(key, value)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func SetIfNotExists(key, value string) <span class="cov8" title="1">{
        _, ok := keyValue.Load(key)
        if !ok </span><span class="cov8" title="1">{
                keyValue.Store(key, value)
        }</span>

}

// GetPH the content of the key as string. if exists.
func GetPHExists(key string) (string, bool) <span class="cov8" title="1">{
        result, ok := keyValue.Load(key)
        if ok </span><span class="cov0" title="0">{
                return result.(string), ok
        }</span>
        <span class="cov8" title="1">return "", ok</span>
}

// GetPH the content of the key. but at least a empty
// string if not exists. so this is not usefull
// to test if the PH was set.
func GetPH(key string) string <span class="cov8" title="1">{
        result, ok := keyValue.Load(key)
        if ok </span><span class="cov8" title="1">{
                GetLogger().WithField(key, result.(string)).Trace("deliver content from placeholder")
                return result.(string)
        }</span>
        <span class="cov8" title="1">GetLogger().WithField("key", key).Trace("returns empty string because key is not set")
        return ""</span>
}

// HandlePlaceHolder replaces all defined placeholders
func HandlePlaceHolder(line string) string <span class="cov8" title="1">{
        var scopeVars map[string]string = make(map[string]string)
        for </span><span class="cov8" title="1">{
                return handlePlaceHolder(line, scopeVars)
        }</span>
}

func HandlePlaceHolderWithScope(line string, scopeVars map[string]string) string <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                return handlePlaceHolder(line, scopeVars)
        }</span>
}

func handlePlaceHolder(line string, scopeVars map[string]string) string <span class="cov8" title="1">{

        // this block is for logging at trace level only
        if GetLogger().IsLevelEnabled(logrus.TraceLevel) </span><span class="cov0" title="0">{

                for key, value := range scopeVars </span><span class="cov0" title="0">{
                        keyName := "${" + key + "}"
                        if strings.Contains(line, keyName) </span><span class="cov0" title="0">{
                                GetLogger().WithField("line", line).Trace("scope replace: source")
                                GetLogger().WithField(keyName, value).Trace("scope replace: variables")
                        }</span>
                        <span class="cov0" title="0">line = strings.ReplaceAll(line, keyName, value)</span>
                }

                <span class="cov0" title="0">keyValue.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                        keyName := "${" + key.(string) + "}"
                        if strings.Contains(line, keyName) </span><span class="cov0" title="0">{
                                GetLogger().WithField("line", line).Trace("replace: source")
                                GetLogger().WithField(keyName, value.(string)).Trace("replace: variables")
                        }</span>
                        <span class="cov0" title="0">line = strings.ReplaceAll(line, keyName, value.(string))
                        line = handleMapVars(line)
                        return true</span>
                })
        }

        <span class="cov8" title="1">for key, value := range scopeVars </span><span class="cov8" title="1">{
                keyName := "${" + key + "}"
                line = strings.ReplaceAll(line, keyName, value)
        }</span>

        <span class="cov8" title="1">keyValue.Range(func(key, value interface{}) bool </span><span class="cov8" title="1">{
                keyName := "${" + key.(string) + "}"
                line = strings.ReplaceAll(line, keyName, value.(string))
                return true
        }</span>)

        <span class="cov8" title="1">line = handleMapVars(line)
        for _, value := range os.Environ() </span><span class="cov8" title="1">{
                pair := strings.SplitN(value, "=", 2)
                if len(pair) == 2 </span><span class="cov8" title="1">{
                        key := pair[0]
                        val := pair[1]
                        keyName := "${" + key + "}"
                        line = strings.ReplaceAll(line, keyName, val)
                }</span>
        }
        <span class="cov8" title="1">return line</span>
}

func handleMapVars(line string) string <span class="cov8" title="1">{
        dataKeys := GetDataKeys()
        if len(dataKeys) == 0 </span><span class="cov8" title="1">{
                return line
        }</span>
        <span class="cov8" title="1">GetLogger().WithField("key-count", len(dataKeys)).Trace("parsing keymap placeholder")
        for _, keyname := range dataKeys </span><span class="cov8" title="1">{
                lookup := "${" + keyname + ":"
                if strings.Contains(line, lookup) </span><span class="cov8" title="1">{
                        start := strings.Index(line, lookup)
                        if start &gt; -1 </span><span class="cov8" title="1">{
                                end := strings.Index(line[start:], "}")
                                if end &gt; -1 </span><span class="cov8" title="1">{
                                        pathLine := line[start+len(lookup) : start+end]
                                        if pathLine != "" </span><span class="cov8" title="1">{
                                                replace := lookup + pathLine + "}"
                                                GetLogger().Debug("replace ", replace)
                                                line = strings.ReplaceAll(line, replace, GetJSONPathValueString(keyname, pathLine))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        GetLogger().WithField("key", lookup).Warn("error by getting end position of prefix")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                GetLogger().WithField("key", lookup).Warn("error by getting start position of prefix")
                        }</span>
                }
        }
        <span class="cov8" title="1">return line</span>
}

// ClearAll removes all entries
func ClearAll() <span class="cov8" title="1">{
        keyValue.Range(func(key, _ interface{}) bool </span><span class="cov8" title="1">{
                keyValue.Delete(key)
                return true
        }</span>)
        <span class="cov8" title="1">watchTaskList.Range(func(key, _ interface{}) bool </span><span class="cov8" title="1">{
                keyValue.Delete(key)
                return true
        }</span>)
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package taskrun

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "golang.org/x/term"

        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/dirhandle"
        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"
)

//var log = logrus.New()
var (
        log = &amp;logrus.Logger{
                Out:       os.Stdout,
                Formatter: new(logrus.TextFormatter),
                Hooks:     make(logrus.LevelHooks),
                Level:     logrus.ErrorLevel,
        }

        // cobra stuff
        showColors    bool
        loglevel      string
        pathIndex     int
        deleteWs      string
        clearTask     bool
        setWs         string
        runAtAll      bool
        leftLen       int
        rightLen      int
        yamlIndent    int
        showInvTarget bool
        uselastIndex  bool
        showHints     bool
        preVars       map[string]string

        rootCmd = &amp;cobra.Command{
                Use:   "contxt",
                Short: "workspaces for the shell",
                Long: `Contxt helps you to organize projects.
it helps also to execute tasks depending these projects.
this task can be used to setup and cleanup the workspace 
if you enter or leave them.`,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)

                }</span>,
        }

        completionCmd = &amp;cobra.Command{
                Use:   "completion [bash|zsh|fish|powershell]",
                Short: "Generate completion script",
                Long: `To load completions:

Bash:

  $ source &lt;(contxt completion bash)

  # To load completions for each session, execute once:
  # Linux:
  $ contxt completion bash &gt; /etc/bash_completion.d/contxt
  # macOS:
  $ contxt completion bash &gt; /usr/local/etc/bash_completion.d/contxt

Zsh:

  # If shell completion is not already enabled in your environment,
  # you will need to enable it.  You can execute the following once:

  $ echo "autoload -U compinit; compinit" &gt;&gt; ~/.zshrc

  # To load completions for each session, execute once:
  $ contxt completion zsh &gt; "${fpath[1]}/_contxt"

  # You will need to start a new shell for this setup to take effect.

fish:

  $ contxt completion fish | source

  # To load completions for each session, execute once:
  $ contxt completion fish &gt; ~/.config/fish/completions/contxt.fish

  `,
                DisableFlagsInUseLine: true,
                ValidArgs:             []string{"bash", "zsh", "fish"},
                Args:                  cobra.ExactValidArgs(1),
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        switch args[0] </span>{
                        case "bash":<span class="cov0" title="0">
                                cmd.Root().GenBashCompletion(os.Stdout)</span>
                        case "zsh":<span class="cov0" title="0">
                                cmd.Root().GenZshCompletion(os.Stdout)</span>
                        case "fish":<span class="cov0" title="0">
                                cmd.Root().GenFishCompletion(os.Stdout, true)</span>
                        }
                },
        }

        gotoCmd = &amp;cobra.Command{
                Use:   "switch",
                Short: "switch workspace",
                Long: `switch the workspace to a existing ones. 
all defined onEnter and onLeave task will be executed 
if these task are defined
`,
                Run: func(_ *cobra.Command, args []string) <span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                for _, arg := range args </span><span class="cov0" title="0">{
                                        doMagicParamOne(arg)
                                }</span>
                        }
                },
                ValidArgsFunction: func(_ *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
                        if len(args) != 0 </span><span class="cov0" title="0">{
                                return nil, cobra.ShellCompDirectiveNoFileComp
                        }</span>
                        <span class="cov0" title="0">targets, found := configure.GetWorkSpacesAsList()
                        if !found </span><span class="cov0" title="0">{
                                return nil, cobra.ShellCompDirectiveNoFileComp
                        }</span>
                        <span class="cov0" title="0">return targets, cobra.ShellCompDirectiveNoFileComp</span>
                },
        }

        workspaceCmd = &amp;cobra.Command{
                Use:   "workspace",
                Short: "create new workspace if not exists, and use them",
                Long: `create a new workspace if not exists.
if the workspace is exists, we will just use them.
you need to set the name for the workspace`,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        workspace, _ := cmd.Flags().GetString("name")
                        if workspace == "" </span><span class="cov0" title="0">{
                                manout.Error("paramater missing", "name is required")
                        }</span> else<span class="cov0" title="0"> {
                                configure.ChangeWorkspace(workspace, callBackOldWs, callBackNewWs)
                        }</span>
                },
        }

        dirCmd = &amp;cobra.Command{
                Use:   "dir",
                Short: "handle workspaces and assigned paths",
                Long:  "manage workspaces and paths they are assigned",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        checkDirFlags(cmd, args)
                        defaulttask := true
                        if pathIndex &gt;= 0 </span><span class="cov0" title="0">{
                                dirhandle.PrintDir(pathIndex)
                                defaulttask = false
                        }</span>

                        <span class="cov0" title="0">if uselastIndex </span><span class="cov0" title="0">{
                                GetLogger().WithField("dirIndex", configure.UsedConfig.LastIndex).Debug("current stored index")
                                dirhandle.PrintDir(configure.UsedConfig.LastIndex)
                                defaulttask = false
                        }</span>

                        <span class="cov0" title="0">if clearTask </span><span class="cov0" title="0">{
                                GetLogger().Info("got clear command")
                                configure.ClearPaths()
                                defaulttask = false
                        }</span>

                        <span class="cov0" title="0">if deleteWs != "" </span><span class="cov0" title="0">{
                                GetLogger().WithField("workspace", deleteWs).Info("got remove workspace option")
                                configure.RemoveWorkspace(deleteWs)
                                defaulttask = false
                        }</span>

                        <span class="cov0" title="0">if setWs != "" </span><span class="cov0" title="0">{
                                GetLogger().WithField("workspace", setWs).Info("create a new worspace")
                                configure.ChangeWorkspace(setWs, callBackOldWs, callBackNewWs)
                                defaulttask = false
                        }</span>

                        <span class="cov0" title="0">if defaulttask </span><span class="cov0" title="0">{
                                printInfo()
                        }</span>
                },
        }

        showPaths = &amp;cobra.Command{
                Use:   "paths",
                Short: "show assigned paths",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        fmt.Println(manout.MessageCln("\t", "paths stored in ", manout.ForeCyan, configure.UsedConfig.CurrentSet))
                        dir, err := dirhandle.Current()
                        if err == nil </span><span class="cov0" title="0">{
                                count := configure.ShowPaths(dir)
                                if count &gt; 0 &amp;&amp; !showHints </span><span class="cov0" title="0">{
                                        fmt.Println()
                                        fmt.Println(manout.MessageCln("\t", "if you have installed the shell functions ", manout.ForeDarkGrey, "(contxt install bash|zsh|fish)", manout.CleanTag, " change the directory by ", manout.BoldTag, "cn ", count-1))
                                        fmt.Println(manout.MessageCln("\t", "this will be the same as ", manout.BoldTag, "cd ", dirhandle.GetDir(count-1)))
                                }</span>
                        }
                },
        }

        findPath = &amp;cobra.Command{
                Use:   "find",
                Short: "find path by a part of them",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        useIndex := -1
                        usePath := "."
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                dirhandle.PrintDir(configure.UsedConfig.LastIndex)
                        }</span> else<span class="cov0" title="0"> {
                                configure.PathWorker(func(index int, path string) </span><span class="cov0" title="0">{
                                        for _, search := range args </span><span class="cov0" title="0">{
                                                found := strings.Contains(path, search)
                                                if found </span><span class="cov0" title="0">{
                                                        useIndex = index
                                                        usePath = path
                                                        GetLogger().WithFields(logrus.Fields{"index": useIndex, "path": usePath}).Debug("Found match by comparing strings")
                                                }</span> else<span class="cov0" title="0"> {
                                                        // this part is not found. but maybe it is a index number?
                                                        sIndex, err := strconv.Atoi(search)
                                                        if err == nil &amp;&amp; index == sIndex </span><span class="cov0" title="0">{
                                                                useIndex = index
                                                                usePath = path
                                                                GetLogger().WithFields(logrus.Fields{"index": useIndex, "path": usePath}).Debug("Found match by using param as index")
                                                        }</span>
                                                }
                                        }
                                })

                                <span class="cov0" title="0">if useIndex &gt;= 0 &amp;&amp; useIndex != configure.UsedConfig.LastIndex </span><span class="cov0" title="0">{
                                        configure.UsedConfig.LastIndex = useIndex
                                        configure.SaveDefaultConfiguration(true)
                                }</span>

                                <span class="cov0" title="0">fmt.Println(usePath)</span>
                        }

                },
        }

        listPaths = &amp;cobra.Command{
                Use:   "list",
                Short: "show assigned paths",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        configure.DisplayWorkSpaces()
                }</span>,
        }

        addPaths = &amp;cobra.Command{
                Use:   "add",
                Short: "add current path (pwd) to the current workspace",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        dir, err := dirhandle.Current()
                        if err == nil </span><span class="cov0" title="0">{
                                fmt.Println(manout.MessageCln("add ", manout.ForeBlue, dir))
                                configure.AddPath(dir)
                                configure.SaveDefaultConfiguration(true)
                        }</span>
                },
        }

        removePath = &amp;cobra.Command{
                Use:   "rm",
                Short: "remove current path (pwd) from the current workspace",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        dir, err := dirhandle.Current()
                        if err == nil </span><span class="cov0" title="0">{
                                fmt.Println(manout.MessageCln("try to remove ", manout.ForeBlue, dir, manout.CleanTag, " from workspace"))
                                removed := configure.RemovePath(dir)
                                if !removed </span><span class="cov0" title="0">{
                                        fmt.Println(manout.MessageCln(manout.ForeRed, "error", manout.CleanTag, " path is not part of the current workspace"))
                                        systools.Exit(1)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Println(manout.MessageCln(manout.ForeGreen, "success"))
                                        configure.SaveDefaultConfiguration(true)
                                }</span>
                        }
                },
        }

        createCmd = &amp;cobra.Command{
                Use:   "create",
                Short: "create taskfile templates",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        WriteTemplate()
                }</span>,
        }

        createImport = &amp;cobra.Command{
                Use:   "import",
                Short: "Create importfile that can be used for templating",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No paths submitted")
                                systools.Exit(1)
                        }</span>
                        <span class="cov0" title="0">_, path, exists, terr := GetTemplate()
                        if terr != nil </span><span class="cov0" title="0">{
                                fmt.Println(manout.MessageCln(manout.ForeRed, "Error ", manout.CleanTag, terr.Error()))
                                systools.Exit(33)
                                return
                        }</span>
                        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                                for _, addPath := range args </span><span class="cov0" title="0">{
                                        err := CreateImport(path, addPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Println("Error adding imports:", err)
                                                systools.Exit(1)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                fmt.Println("no taskfile exists. create these first by contxt create")
                                systools.Exit(1)
                        }</span>

                },
        }

        versionCmd = &amp;cobra.Command{
                Use:   "version",
                Short: "prints current version",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        fmt.Println("version", configure.GetVersion(), "build", configure.GetBuild())
                }</span>,
        }

        exportCmd = &amp;cobra.Command{
                Use:   "export",
                Short: "exports the script section of an target like a bash script",
                Long: `for extracting tasks commands in a format that can be executed as a shell script.
this will be a plain export without handling dynamic generated placeholders (default placeholders will be parsed)  and contxt macros.
also go-template imports will be handled.
                `,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        for _, target := range args </span><span class="cov0" title="0">{
                                outStr, err := ExportTask(target)
                                if err == nil </span><span class="cov0" title="0">{
                                        fmt.Println("# --- -------------- ---------- ----- ------ ")
                                        fmt.Println("# --- contxt export of target " + target)
                                        fmt.Println("# --- -------------- ---------- ----- ------ ")
                                        fmt.Println()
                                        fmt.Println(HandlePlaceHolder(outStr))
                                }</span> else<span class="cov0" title="0"> {
                                        panic(err)</span>
                                }

                        }
                },
                ValidArgsFunction: func(_ *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
                        if len(args) != 0 </span><span class="cov0" title="0">{
                                return nil, cobra.ShellCompDirectiveNoFileComp
                        }</span>
                        //targets, found := targetsAsMap()
                        <span class="cov0" title="0">targets, found := GetAllTargets()
                        if !found </span><span class="cov0" title="0">{
                                return nil, cobra.ShellCompDirectiveNoFileComp
                        }</span>
                        <span class="cov0" title="0">return targets, cobra.ShellCompDirectiveNoFileComp</span>
                },
        }

        lintCmd = &amp;cobra.Command{
                Use:   "lint",
                Short: "checking the task file",
                Long: `to check if the task file contains the expected changes.
use --full to see properties they are nor used.
you will also see if a unexpected propertie found `,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        leftLen, _ := cmd.Flags().GetInt("left")
                        rightLen, _ := cmd.Flags().GetInt("right")
                        showall, _ := cmd.Flags().GetBool("full")
                        yamlParse, _ := cmd.Flags().GetBool("yaml")
                        yamlIndent, _ := cmd.Flags().GetInt("indent")
                        okay := false
                        if yamlParse </span><span class="cov0" title="0">{
                                ShowAsYaml(true, false, yamlIndent)
                                okay = LintOut(leftLen, 0, false, true)
                        }</span> else<span class="cov0" title="0"> {
                                okay = LintOut(leftLen, rightLen, showall, false)
                        }</span>

                        <span class="cov0" title="0">if !okay </span><span class="cov0" title="0">{
                                systools.Exit(1)
                        }</span>

                },
        }

        installCmd = &amp;cobra.Command{
                Use:   "install",
                Short: "install shell functions",
                Long: `updates shell related files to get contxt running
                as shortcut ctx. this will allow changing directories depending
                on a context switch.
                `,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                }</span>,
        }

        installBashRc = &amp;cobra.Command{
                Use:   "bashrc",
                Short: "updates bashrc for using ctx alias",
                Long: `writes needed functions into the users private .bashrc file.
                This includes code completion and the ctx alias.
                `,
                Run: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
                        BashUser()
                }</span>,
        }

        installFish = &amp;cobra.Command{
                Use:   "fish",
                Short: "create fish shell env for ctx",
                Long: `create needed fish functions, auto completion for ctx
                `,
                Run: func(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
                        FishUpdate(cmd)
                }</span>,
        }

        installZsh = &amp;cobra.Command{
                Use:   "zsh",
                Short: "create zsh shell env for ctx",
                Long: `create needed zsh functions and auto completion for zsh
                `,
                Run: func(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
                        ZshUpdate(cmd)
                }</span>,
        }

        runCmd = &amp;cobra.Command{
                Use:   "run",
                Short: "run a target in contxt.yml task file",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        checkRunFlags(cmd, args)
                        GetLogger().WithField("args", args).Info("Run triggered")
                        GetLogger().WithField("all", runAtAll).Info("all workspaces?")

                        // set variables by argument
                        for preKey, preValue := range preVars </span><span class="cov0" title="0">{
                                GetLogger().WithFields(logrus.Fields{"key": preKey, "val": preValue}).Info("prevalue set by argument")
                                SetPH(preKey, preValue)
                        }</span>

                        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                                printTargets()
                        }</span>

                        <span class="cov0" title="0">for _, arg := range args </span><span class="cov0" title="0">{
                                GetLogger().WithField("target", arg).Info("try to run target")

                                path, err := dirhandle.Current()
                                if err == nil </span><span class="cov0" title="0">{
                                        if runAtAll </span><span class="cov0" title="0">{
                                                configure.PathWorker(func(_ int, path string) </span><span class="cov0" title="0">{
                                                        GetLogger().WithField("path", path).Info("change dir")
                                                        os.Chdir(path)
                                                        runTargets(path, arg)
                                                }</span>)
                                        } else<span class="cov0" title="0"> {
                                                runTargets(path, arg)
                                        }</span>
                                }
                        }

                },
                ValidArgsFunction: func(_ *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
                        if len(args) != 0 </span><span class="cov0" title="0">{
                                return nil, cobra.ShellCompDirectiveNoFileComp
                        }</span>
                        <span class="cov0" title="0">targets, found := GetAllTargets()
                        if !found </span><span class="cov0" title="0">{
                                return nil, cobra.ShellCompDirectiveNoFileComp
                        }</span>
                        <span class="cov0" title="0">return targets, cobra.ShellCompDirectiveNoFileComp</span>
                },
        }
        sharedCmd = &amp;cobra.Command{
                Use:   "shared",
                Short: "manage shared tasks",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                }</span>,
        }

        sharedListCmd = &amp;cobra.Command{
                Use:   "list",
                Short: "list local shared tasks",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        sharedDirs, _ := ListUseCases(false)
                        for _, sharedPath := range sharedDirs </span><span class="cov0" title="0">{
                                fmt.Println(sharedPath)
                        }</span>
                },
        }

        sharedUpdateCmd = &amp;cobra.Command{
                Use:   "update",
                Short: "updates shared uses if possible (git based)",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        checkDefaultFlags(cmd, args)
                        useCases, err := ListUseCases(true)
                        if err == nil </span><span class="cov0" title="0">{
                                for _, path := range useCases </span><span class="cov0" title="0">{
                                        fmt.Println(manout.MessageCln("check usage ", manout.ForeCyan, path))
                                        UpdateUseCase(path)
                                }</span>
                        }
                },
        }
)

func checkRunFlags(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
        runAtAll, _ = cmd.Flags().GetBool("all-paths")
        showInvTarget, _ = cmd.Flags().GetBool("all-targets")
}</span>

func checkDirFlags(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
        pindex, err := cmd.Flags().GetInt("index")
        if err == nil &amp;&amp; pindex &gt;= 0 </span><span class="cov0" title="0">{
                pathIndex = pindex
        }</span>
        <span class="cov0" title="0">GetLogger().WithFields(logrus.Fields{"current": configure.UsedConfig.LastIndex, "index": pindex}).Trace("Index detection")
        if pindex &gt;= 0 &amp;&amp; pindex != configure.UsedConfig.LastIndex </span><span class="cov0" title="0">{
                configure.UsedConfig.LastIndex = pindex
                configure.SaveDefaultConfiguration(true)
        }</span>

        <span class="cov0" title="0">clearTask, _ = cmd.Flags().GetBool("clear")
        deleteWs, _ = cmd.Flags().GetString("delete")
        setWs, _ = cmd.Flags().GetString("workspace")
        uselastIndex, _ = cmd.Flags().GetBool("last")</span>
}

func checkDefaultFlags(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
        color, err := cmd.Flags().GetBool("coloroff")
        if err == nil &amp;&amp; color </span><span class="cov0" title="0">{
                manout.ColorEnabled = false
        }</span>

        <span class="cov0" title="0">loglevel, _ = cmd.Flags().GetString("loglevel")
        setLoggerByArg()</span>
}

func initCobra() <span class="cov0" title="0">{
        // create dir command
        dirCmd.AddCommand(showPaths)
        dirCmd.AddCommand(addPaths)
        dirCmd.AddCommand(listPaths)
        dirCmd.AddCommand(removePath)
        dirCmd.AddCommand(findPath)

        dirCmd.Flags().IntVarP(&amp;pathIndex, "index", "i", -1, "get path by the index in order the paths are stored")
        dirCmd.Flags().BoolP("clear", "C", false, "remove all path assigments")
        dirCmd.Flags().BoolP("last", "l", false, "get last used path index number")
        dirCmd.Flags().StringP("delete", "d", "", "remove workspace")
        dirCmd.Flags().StringP("workspace", "w", "", "set workspace. if not exists a new workspace will be created")

        runCmd.Flags().BoolP("all-paths", "a", false, "run targets in all paths in the current workspace")
        runCmd.Flags().Bool("all-targets", false, "show all targets. including invisible")
        runCmd.Flags().StringToStringVarP(&amp;preVars, "var", "v", nil, "set variables by keyname and value.")

        createCmd.AddCommand(createImport)

        //rootCmd.PersistentFlags().BoolVarP(&amp;Experimental, "experimental", "E", true, "enable experimental features")
        rootCmd.PersistentFlags().BoolVarP(&amp;showColors, "coloroff", "c", false, "disable usage of colors in output")
        rootCmd.PersistentFlags().BoolVarP(&amp;showHints, "nohints", "n", false, "disable printing hints")
        rootCmd.PersistentFlags().StringVar(&amp;loglevel, "loglevel", "FATAL", "set loglevel")
        rootCmd.AddCommand(dirCmd)
        rootCmd.AddCommand(runCmd)
        rootCmd.AddCommand(createCmd)
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(exportCmd)

        lintCmd.Flags().IntVar(&amp;leftLen, "left", 45, "set the width for the source code")
        lintCmd.Flags().IntVar(&amp;rightLen, "right", 55, "set the witdh for the current state view")
        lintCmd.Flags().IntVar(&amp;yamlIndent, "indent", 2, "set indent for yaml output by using lint --yaml")
        lintCmd.Flags().Bool("full", false, "print also unset properties")
        lintCmd.Flags().Bool("yaml", false, "display parsed taskfile as yaml file")
        lintCmd.Flags().Bool("parse", false, "parse second level keywords (#@...)")

        rootCmd.AddCommand(lintCmd)

        rootCmd.AddCommand(completionCmd)
        rootCmd.AddCommand(gotoCmd)

        installCmd.AddCommand(installBashRc)
        installCmd.AddCommand(installFish)
        installCmd.AddCommand(installZsh)
        rootCmd.AddCommand(installCmd)

        workspaceCmd.Flags().String("name", "", "set the name for the workspace. REQUIRED")
        rootCmd.AddCommand(workspaceCmd)

        sharedCmd.AddCommand(sharedListCmd)
        sharedCmd.AddCommand(sharedUpdateCmd)
        rootCmd.AddCommand(sharedCmd)

}</span>

func setLoggerByArg() <span class="cov0" title="0">{
        if loglevel != "" </span><span class="cov0" title="0">{
                lvl, err := logrus.ParseLevel(loglevel)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">log.SetLevel(lvl)</span>
        }
}

func initLogger() {<span class="cov0" title="0">
        //log.Out = os.Stdout
        //log.SetLevel(logrus.DebugLevel)

}</span>

func executeCobra() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

// GetLogger is the main Logger instance
func GetLogger() *logrus.Logger <span class="cov8" title="1">{
        return log
}</span>

func shortcuts() bool <span class="cov0" title="0">{
        if len(os.Args) == 2 </span><span class="cov0" title="0">{

                switch os.Args[1] </span>{
                case "dir", "run", "create", "version":<span class="cov0" title="0">
                        return false</span>
                default:<span class="cov0" title="0">
                        foundATask := doMagicParamOne(os.Args[1])
                        return foundATask</span>

                }
        }
        <span class="cov0" title="0">return false</span>
}

func InitDefaultVars() <span class="cov8" title="1">{
        SetPH("CTX_OS", configure.GetOs())
        if configure.GetOs() == "windows" </span><span class="cov0" title="0">{
                manout.ColorEnabled = false
                if os.Getenv("CTX_COLOR") == "ON" </span><span class="cov0" title="0">{
                        manout.ColorEnabled = true
                }</span> else<span class="cov0" title="0"> {
                        cmd := "$PSVersionTable.PSVersion.Major"
                        cmdArg := []string{"-nologo", "-noprofile"}
                        version := ""
                        ExecuteScriptLine(GetDefaultCmd(), cmdArg, cmd, func(s string, e error) bool </span><span class="cov0" title="0">{
                                version = s
                                return true
                        }</span>, func(p *os.Process) {<span class="cov0" title="0">

                        }</span>)
                        <span class="cov0" title="0">SetPH("CTX_PS_VERSION", version)
                        if version &gt;= "7" </span><span class="cov0" title="0">{
                                manout.ColorEnabled = true
                        }</span>
                }
        }
        // we checking the console support
        <span class="cov8" title="1">if !term.IsTerminal(int(os.Stdout.Fd())) </span><span class="cov8" title="1">{
                manout.ColorEnabled = false
        }</span>
}

// MainExecute runs main. parsing flags
func MainExecute() <span class="cov0" title="0">{
        pathIndex = -1
        initLogger()
        InitDefaultVars()
        var configErr = configure.InitConfig()
        if configErr != nil </span><span class="cov0" title="0">{
                log.Fatal(configErr)
        }</span>

        <span class="cov0" title="0">currentDir, _ := dirhandle.Current()
        SetPH("CTX_PWD", currentDir)

        // first handle shortcuts
        // before we get cobra controll
        if !shortcuts() </span><span class="cov0" title="0">{
                initCobra()
                err := executeCobra()
                if err != nil </span><span class="cov0" title="0">{
                        manout.Error("error", err)
                        systools.Exit(1)
                }</span>

        }

}

func callBackOldWs(oldws string) bool <span class="cov0" title="0">{
        GetLogger().Info("OLD workspace: ", oldws)
        // get all paths first
        configure.PathWorker(func(_ int, path string) </span><span class="cov0" title="0">{

                os.Chdir(path)
                template, templateFile, exists, _ := GetTemplate()

                GetLogger().WithFields(logrus.Fields{
                        "templateFile": templateFile,
                        "exists":       exists,
                        "path":         path,
                }).Debug("path parsing")

                if exists &amp;&amp; template.Config.Autorun.Onleave != "" </span><span class="cov0" title="0">{
                        onleaveTarget := template.Config.Autorun.Onleave
                        GetLogger().WithFields(logrus.Fields{
                                "templateFile": templateFile,
                                "target":       onleaveTarget,
                        }).Info("execute leave-action")
                        RunTargets(onleaveTarget, true)

                }</span>

        })
        <span class="cov0" title="0">return true</span>
}

func callBackNewWs(newWs string) <span class="cov0" title="0">{
        GetLogger().Info("NEW workspace: ", newWs)
        configure.PathWorker(func(_ int, path string) </span><span class="cov0" title="0">{

                os.Chdir(path)
                template, templateFile, exists, _ := GetTemplate()

                GetLogger().WithFields(logrus.Fields{
                        "templateFile": templateFile,
                        "exists":       exists,
                        "path":         path,
                }).Debug("path parsing")

                if exists &amp;&amp; template.Config.Autorun.Onenter != "" </span><span class="cov0" title="0">{
                        onEnterTarget := template.Config.Autorun.Onenter
                        GetLogger().WithFields(logrus.Fields{
                                "templateFile": templateFile,
                                "target":       onEnterTarget,
                        }).Info("execute enter-action")
                        RunTargets(onEnterTarget, true)
                }</span>

        })
}

func doMagicParamOne(param string) bool <span class="cov0" title="0">{
        result := false
        if param == "show-the-rainbow" </span><span class="cov0" title="0">{
                systools.TestColorCombinations()
                return true
        }</span>
        // param is a workspace ?
        <span class="cov0" title="0">configure.WorkSpaces(func(ws string) </span><span class="cov0" title="0">{
                if param == ws </span><span class="cov0" title="0">{
                        configure.ChangeWorkspace(ws, callBackOldWs, callBackNewWs)
                        result = true
                }</span>
        })

        <span class="cov0" title="0">return result</span>
}

func GetAllTargets() ([]string, bool) <span class="cov0" title="0">{
        plainTargets, found := targetsAsMap()
        template, _, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                return plainTargets, found
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                shareds := detectSharedTargetsAsMap(template)
                plainTargets = append(plainTargets, shareds...)
        }</span>
        <span class="cov0" title="0">return plainTargets, exists &amp;&amp; found</span>
}

func detectSharedTargetsAsMap(current configure.RunConfig) []string <span class="cov0" title="0">{
        var targets []string
        SharedFolderExecuter(current, func(_, _ string) </span><span class="cov0" title="0">{
                sharedTargets, have := targetsAsMap()
                if have </span><span class="cov0" title="0">{
                        targets = append(targets, sharedTargets...)
                }</span>
        })

        <span class="cov0" title="0">return targets</span>
}

func ExistInStrMap(testStr string, check []string) bool <span class="cov8" title="1">{
        for _, str := range check </span><span class="cov8" title="1">{
                if strings.TrimSpace(str) == strings.TrimSpace(testStr) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func targetsAsMap() ([]string, bool) <span class="cov0" title="0">{
        var targets []string
        template, _, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                targets = append(targets, terr.Error())
                return targets, false
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return templateTargetsAsMap(template)
        }</span>
        <span class="cov0" title="0">return targets, false</span>
}

func templateTargetsAsMap(template configure.RunConfig) ([]string, bool) <span class="cov0" title="0">{
        var targets []string
        found := false

        if len(template.Task) &gt; 0 </span><span class="cov0" title="0">{
                for _, tasks := range template.Task </span><span class="cov0" title="0">{
                        if !ExistInStrMap(tasks.ID, targets) &amp;&amp; (!tasks.Options.Invisible || showInvTarget) </span><span class="cov0" title="0">{
                                found = true
                                targets = append(targets, strings.TrimSpace(tasks.ID))
                        }</span>
                }
        }

        <span class="cov0" title="0">return targets, found</span>
}

func printTargets() <span class="cov0" title="0">{

        template, path, exists, terr := GetTemplate()
        if terr != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln(manout.ForeDarkGrey, "used taskfile:\t", manout.CleanTag, path))
                fmt.Println(manout.MessageCln(manout.ForeDarkGrey, "tasks count:  \t", manout.CleanTag, len(template.Task)))
                if len(template.Task) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println(manout.MessageCln(manout.BoldTag, "existing targets:"))
                        taskList, _ := templateTargetsAsMap(template)
                        for _, tasks := range taskList </span><span class="cov0" title="0">{
                                fmt.Println("\t", tasks)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(manout.MessageCln("that is what we gor so far:"))
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">sharedTargets := detectSharedTargetsAsMap(template)
                if len(sharedTargets) &gt; 0 </span><span class="cov0" title="0">{

                        for _, stasks := range sharedTargets </span><span class="cov0" title="0">{
                                fmt.Println("\t", stasks, manout.MessageCln(manout.ForeDarkGrey, " shared", manout.CleanTag))
                        }</span>

                }
        } else<span class="cov0" title="0"> {
                fmt.Println(manout.MessageCln(manout.ForeCyan, "no task-file exists. you can create one by ", manout.CleanTag, " contxt create"))
        }</span>
}

func runTargets(_ string, targets string) <span class="cov0" title="0">{
        RunTargets(targets, true)
}</span>

func printOutHeader() <span class="cov0" title="0">{
        fmt.Println(manout.MessageCln(manout.BoldTag, manout.ForeWhite, "cont(e)xt ", manout.CleanTag, configure.GetVersion()))
        fmt.Println(manout.MessageCln(manout.Dim, " build-no [", manout.ResetDim, configure.GetBuild(), manout.Dim, "]"))
        if configure.GetOs() == "windows" </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln(manout.BoldTag, manout.ForeWhite, " powershell version ", manout.CleanTag, GetPH("CTX_PS_VERSION")))
        }</span>
}

func printInfo() <span class="cov0" title="0">{
        printOutHeader()
        printPaths()
}</span>

func printPaths() <span class="cov0" title="0">{
        dir, err := dirhandle.Current()
        if err == nil </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln(manout.ForeWhite, " current directory: ", manout.BoldTag, dir))
                fmt.Println(manout.MessageCln(manout.ForeWhite, " current workspace: ", manout.BoldTag, configure.UsedConfig.CurrentSet))
                notWorkspace := true
                pathColor := manout.ForeLightBlue
                if !configure.PathMeightPartOfWs(dir) </span><span class="cov0" title="0">{
                        pathColor = manout.ForeLightMagenta
                }</span> else<span class="cov0" title="0"> {
                        notWorkspace = false
                }</span>
                <span class="cov0" title="0">fmt.Println(" contains paths:")
                configure.PathWorker(func(index int, path string) </span><span class="cov0" title="0">{
                        template, _, exists, _ := GetTemplate()
                        add := ""
                        if strings.Contains(dir, path) </span><span class="cov0" title="0">{
                                add = manout.ResetDim + manout.ForeCyan
                        }</span>
                        <span class="cov0" title="0">if dir == path </span><span class="cov0" title="0">{
                                add = manout.ResetDim + manout.ForeGreen
                        }</span>
                        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                                outTasks := ""
                                targets, _ := templateTargetsAsMap(template)
                                for _, tasks := range targets </span><span class="cov0" title="0">{
                                        outTasks = outTasks + " " + tasks
                                }</span>

                                <span class="cov0" title="0">fmt.Println(manout.MessageCln("       path: ", manout.Dim, " no ", manout.ForeYellow, index, " ", pathColor, add, path, manout.CleanTag, " targets", "[", manout.ForeYellow, outTasks, manout.CleanTag, "]"))</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Println(manout.MessageCln("       path: ", manout.Dim, " no ", manout.ForeYellow, index, " ", pathColor, add, path))
                        }</span>
                })
                <span class="cov0" title="0">if notWorkspace </span><span class="cov0" title="0">{
                        fmt.Println()
                        fmt.Println(manout.MessageCln(manout.BackYellow, manout.ForeBlue, " WARNING ! ", manout.CleanTag, "\tyou are currently in none of the assigned locations."))
                        fmt.Println("\t\tso maybe you are using the wrong workspace")
                }</span>
                <span class="cov0" title="0">if !showHints </span><span class="cov0" title="0">{
                        fmt.Println()
                        fmt.Println(manout.MessageCln(" targets can be executes by ", manout.BoldTag, "contxt run &lt;targetname&gt;", manout.CleanTag, "(for the current directory)"))
                        fmt.Println(manout.MessageCln(" a target can also be executed in all stored paths by ", manout.BoldTag, "contxt run -a &lt;targetname&gt;", manout.CleanTag, " independend from current path"))
                }</span>

                <span class="cov0" title="0">fmt.Println()
                if !showHints </span><span class="cov0" title="0">{
                        fmt.Println(manout.MessageCln(" all workspaces:", " ... change by ", manout.BoldTag, "contxt &lt;workspace&gt;", ""))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(manout.MessageCln(" all workspaces:"))
                }</span>
                <span class="cov0" title="0">configure.WorkSpaces(func(name string) </span><span class="cov0" title="0">{
                        if name == configure.UsedConfig.CurrentSet </span><span class="cov0" title="0">{
                                fmt.Println(manout.MessageCln("\t[ ", manout.BoldTag, name, manout.CleanTag, " ]"))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(manout.MessageCln("\t  ", name, "   "))
                        }</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"

        "github.com/sirupsen/logrus"
        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/dirhandle"
        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"
)

var config_file string = "version.conf"

// CheckOrCreateUseConfig get a usecase like swaros/ctx-git and checks
// if a local copy of them exists.
// if they not exists it creates the local directoy and uses git to
// clone the content.
// afterwards it writes a version.conf in the forlder above of content
// and stores the current hashes
func CheckOrCreateUseConfig(externalUseCase string) (string, error) <span class="cov0" title="0">{
        GetLogger().WithField("usage", externalUseCase).Info("trying to solve usecase")
        path := ""                                                  // just as default
        sharedPath, err := configure.GetSharedPath(externalUseCase) // get the main path for shared content
        if err == nil &amp;&amp; sharedPath != "" </span><span class="cov0" title="0">{                         // no error and not an empty path
                isThere, dirError := dirhandle.Exists(sharedPath) // do we have the main shared directory?
                GetLogger().WithFields(logrus.Fields{"path": sharedPath, "exists": isThere, "err": dirError}).Info("using shared contxt tasks")
                if dirError != nil </span><span class="cov0" title="0">{ // this is NOT related to not exists. it is an error while checking if the path exists
                        log.Fatal(dirError)
                }</span> else<span class="cov0" title="0"> {
                        if !isThere </span><span class="cov0" title="0">{ // directory not exists
                                GetLogger().WithField("path", sharedPath).Info("shared directory not exists. try to checkout by git (github)")
                                path = createUseByGit(externalUseCase, sharedPath) // create dirs and checkout content if possible. fit the path also

                        }</span> else<span class="cov0" title="0"> { // directory exists
                                path = getSourcePath(sharedPath)
                                exists, _ := dirhandle.Exists(path)
                                if !exists </span><span class="cov0" title="0">{
                                        manout.Error("USE Error", "shared usecase not exist and can not be downloaded", " ", path)
                                        systools.Exit(10)
                                }</span>
                                <span class="cov0" title="0">GetLogger().WithField("shared-path", path).Debug("use existing shared path")</span>
                        }
                }
        }
        <span class="cov0" title="0">return path, nil</span>
}

func createSharedUsageDir(sharedPath string) error <span class="cov0" title="0">{
        exists, _ := dirhandle.Exists(sharedPath)
        if !exists </span><span class="cov0" title="0">{
                // create dir
                GetLogger().WithField("path", sharedPath).Info("shared directory not exists. try to create them")
                err := os.MkdirAll(sharedPath, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">GetLogger().WithField("path", sharedPath).Info("shared directory exists already")
        return nil</span>
}

func HandleUsecase(externalUseCase string) string <span class="cov0" title="0">{
        path, _ := CheckOrCreateUseConfig(externalUseCase)
        return path
}</span>

func StripContxtUseDir(path string) string <span class="cov0" title="0">{
        sep := fmt.Sprintf("%c", os.PathSeparator)
        newpath := strings.TrimSuffix(path, sep)

        parts := strings.Split(newpath, sep)
        cleanDir := ""
        if len(parts) &gt; 1 &amp;&amp; parts[len(parts)-1] == "source" </span><span class="cov0" title="0">{
                parts = parts[:len(parts)-1]
        }</span>
        <span class="cov0" title="0">for _, subpath := range parts </span><span class="cov0" title="0">{
                if subpath != "" </span><span class="cov0" title="0">{
                        cleanDir = cleanDir + sep + subpath
                }</span>

        }
        <span class="cov0" title="0">return cleanDir</span>
}

func UpdateUseCase(fullPath string) <span class="cov0" title="0">{
        //usecase, version := getUseInfo("", fullPath)
        exists, config, _ := getRepoConfig(fullPath)
        if exists </span><span class="cov0" title="0">{
                GetLogger().WithFields(logrus.Fields{"config": config}).Debug("version info")
                fmt.Println(manout.MessageCln(" remote:", manout.ForeLightBlue, " ", config.Repositiory))
                updateGitRepo(config, true, fullPath)

        }</span> else<span class="cov0" title="0"> {
                fmt.Println(manout.MessageCln(" local shared:", manout.ForeYellow, " ", fullPath, manout.ForeDarkGrey, "(not updatable. ignored)"))
        }</span>
}

func ListUseCases(fullPath bool) ([]string, error) <span class="cov0" title="0">{
        var sharedDirs []string
        sharedPath, perr := configure.GetSharedPath("")
        if perr == nil </span><span class="cov0" title="0">{
                errWalk := filepath.Walk(sharedPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                                var basename = filepath.Base(path)
                                var directory = filepath.Dir(path)

                                if basename == ".contxt.yml" </span><span class="cov0" title="0">{
                                        if fullPath </span><span class="cov0" title="0">{
                                                sharedDirs = append(sharedDirs, StripContxtUseDir(directory))
                                        }</span> else<span class="cov0" title="0"> {
                                                releative := strings.Replace(StripContxtUseDir(directory), sharedPath, "", 1)
                                                sharedDirs = append(sharedDirs, releative)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">return sharedDirs, errWalk</span>
        }
        <span class="cov0" title="0">return sharedDirs, perr</span>
}

func GetUseInfo(usecase, _ string) (string, string) <span class="cov8" title="1">{
        parts := strings.Split(usecase, "@")
        version := "refs/heads/main"
        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                usecase = parts[0]
                version = "refs/tags/" + parts[1]
        }</span>
        <span class="cov8" title="1">return usecase, version</span>
}

func updateGitRepo(config configure.GitVersionInfo, doUpdate bool, workDir string) bool <span class="cov0" title="0">{
        if config.Repositiory != "" </span><span class="cov0" title="0">{
                fmt.Print(manout.MessageCln(" Reference:", manout.ForeLightBlue, " ", config.Reference))
                fmt.Print(manout.MessageCln(" Current:", manout.ForeLightBlue, " ", config.HashUsed))
                returnBool := false
                checkGitVersionInfo(config.Repositiory, func(hash, reference string) </span><span class="cov0" title="0">{
                        if reference == config.Reference </span><span class="cov0" title="0">{
                                fmt.Print(manout.MessageCln(manout.ForeLightGreen, "[EXISTS]"))
                                if hash == config.HashUsed </span><span class="cov0" title="0">{
                                        fmt.Print(manout.MessageCln(manout.ForeLightGreen, " [up to date]"))
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Print(manout.MessageCln(manout.ForeYellow, " [update found]"))
                                        if doUpdate </span><span class="cov0" title="0">{
                                                gCode := executeGitUpdate(getSourcePath(workDir))
                                                if gCode == ExitOk </span><span class="cov0" title="0">{
                                                        config.HashUsed = hash
                                                        if werr := writeGitConfig(workDir+"/"+config_file, config); werr != nil </span><span class="cov0" title="0">{
                                                                manout.Error("unable to create version info", werr)
                                                                returnBool = false
                                                        }</span> else<span class="cov0" title="0"> {
                                                                returnBool = true
                                                        }</span>
                                                }
                                        }
                                }
                        }
                })
                <span class="cov0" title="0">fmt.Println(".")
                return returnBool</span>
        }
        <span class="cov0" title="0">return false</span>
}

func executeGitUpdate(path string) int <span class="cov0" title="0">{
        currentDir, _ := dirhandle.Current()
        os.Chdir(path)
        gitCmd := "git pull"
        exec, args := GetExecDefaults()
        exitCode, _, _ := ExecuteScriptLine(exec, args, gitCmd, func(feed string, e error) bool </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln("\tgit: ", manout.ForeLightYellow, feed))
                return true
        }</span>, func(process *os.Process) <span class="cov0" title="0">{
                pidStr := fmt.Sprintf("%d", process.Pid)
                GetLogger().WithFields(logrus.Fields{"process": pidStr}).Debug("git process id")
        }</span>)
        <span class="cov0" title="0">os.Chdir(currentDir)
        return exitCode</span>
}

// first argument is the hash and the second one is the version
func checkGitVersionInfo(usecase string, callback func(string, string)) (int, int, error) <span class="cov0" title="0">{
        gitCmd := "git ls-remote --refs https://github.com/" + usecase
        exec, args := GetExecDefaults()
        internalExitCode, cmdError, err := ExecuteScriptLine(exec, args, gitCmd, func(feed string, e error) bool </span><span class="cov0" title="0">{
                gitInfo := strings.Split(feed, "\t")
                if len(gitInfo) &gt;= 2 </span><span class="cov0" title="0">{
                        callback(gitInfo[0], gitInfo[1])
                }</span>
                <span class="cov0" title="0">return true</span>
        }, func(process *os.Process) <span class="cov0" title="0">{
                pidStr := fmt.Sprintf("%d", process.Pid)
                GetLogger().WithFields(logrus.Fields{"process": pidStr}).Debug("git process id")
        }</span>)
        <span class="cov0" title="0">return internalExitCode, cmdError, err</span>
}

func createUseByGit(usecase, pathTouse string) string <span class="cov0" title="0">{
        usecase, version := GetUseInfo(usecase, pathTouse) // get needed git ref and usecase by the requested usage (like from swaros/ctx-gt@v0.0.1)
        GetLogger().WithFields(logrus.Fields{"use": usecase, "path": pathTouse, "version": version}).Debug("Import Usecase")
        path := ""
        gitCmd := "git ls-remote --refs https://github.com/" + usecase
        exec, args := GetExecDefaults()
        var gitInfo []string
        internalExitCode, cmdError, _ := ExecuteScriptLine(exec, args, gitCmd, func(feed string, e error) bool </span><span class="cov0" title="0">{
                gitInfo = strings.Split(feed, "\t")
                if len(gitInfo) &gt;= 2 &amp;&amp; gitInfo[1] == version </span><span class="cov0" title="0">{
                        GetLogger().WithFields(logrus.Fields{"git-info": gitInfo, "cnt": len(gitInfo)}).Debug("found matching version")
                        cfg, versionErr := getOrCreateRepoConfig(gitInfo[1], gitInfo[0], usecase, pathTouse)
                        if versionErr == nil </span><span class="cov0" title="0">{
                                cfg = takeCareAboutRepo(pathTouse, cfg)
                                path = cfg.Path
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }, func(process *os.Process) <span class="cov0" title="0">{
                pidStr := fmt.Sprintf("%d", process.Pid)
                GetLogger().WithFields(logrus.Fields{"process": pidStr}).Debug("git process id")
        }</span>)
        <span class="cov0" title="0">if internalExitCode != ExitOk </span><span class="cov0" title="0">{
                // git info was failing. so we did not create anything right now by using git
                // so now we have to check if this is a local repository
                GetLogger().WithFields(logrus.Fields{
                        "exitCode":      internalExitCode,
                        "cmd-exit-code": cmdError,
                }).Warning("failed get version info from git")
                exists, _ := dirhandle.Exists(pathTouse)
                if exists </span><span class="cov0" title="0">{
                        existsSource, _ := dirhandle.Exists(getSourcePath(pathTouse))
                        if existsSource </span><span class="cov0" title="0">{
                                return getSourcePath(pathTouse)
                        }</span>
                }
                <span class="cov0" title="0">GetLogger().WithField("path", pathTouse).Fatal("Local Usage folder not exists (+ ./source)")
                systools.Exit(internalExitCode)</span>
        }
        <span class="cov0" title="0">return path</span>
}

func getRepoConfig(pathTouse string) (bool, configure.GitVersionInfo, error) <span class="cov0" title="0">{
        hashChk, hashError := dirhandle.Exists(getVersionOsPath(pathTouse))
        var versionConf configure.GitVersionInfo
        if hashError != nil </span><span class="cov0" title="0">{
                return false, versionConf, hashError
        }</span> else<span class="cov0" title="0"> if hashChk </span><span class="cov0" title="0">{
                versionConf, err := loadGitConfig(getVersionOsPath(pathTouse), versionConf)
                return err == nil, versionConf, err
        }</span>
        <span class="cov0" title="0">GetLogger().WithField("path", pathTouse).Warning("no version info. seems to be a local shared.")
        return false, versionConf, nil</span>
}

func getSourcePath(pathTouse string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s%s", pathTouse, string(os.PathSeparator), "source")
}</span>

func getVersionOsPath(pathTouse string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s%s", pathTouse, string(os.PathSeparator), config_file)
}</span>

func getOrCreateRepoConfig(ref, hash, usecase, pathTouse string) (configure.GitVersionInfo, error) <span class="cov0" title="0">{
        var versionConf configure.GitVersionInfo
        versionFilename := getVersionOsPath(pathTouse)

        // check if the useage folder exists and create them if not
        if pathWErr := createSharedUsageDir(pathTouse); pathWErr != nil </span><span class="cov0" title="0">{
                manout.Error("error while create directory:", pathWErr)
                return versionConf, pathWErr
        }</span>

        <span class="cov0" title="0">hashChk, hashError := dirhandle.Exists(versionFilename)
        if hashError != nil </span><span class="cov0" title="0">{
                manout.Error("error while checking directory:", hashError)
                return versionConf, hashError
        }</span> else<span class="cov0" title="0"> if !hashChk </span><span class="cov0" title="0">{

                versionConf.Repositiory = usecase
                versionConf.HashUsed = hash
                versionConf.Reference = ref

                GetLogger().WithField("file", versionFilename).Info("Try to create version info")
                if werr := writeGitConfig(versionFilename, versionConf); werr != nil </span><span class="cov0" title="0">{
                        GetLogger().WithField("file", versionFilename).Error("error by create version info: ", werr)
                        manout.Error("unable to create version info ", versionFilename, werr)
                        return versionConf, werr
                }</span>

                <span class="cov0" title="0">GetLogger().WithField("config", versionConf).Debug("Create new Config")</span>
        } else<span class="cov0" title="0"> {
                versionConf, vErr := loadGitConfig(versionFilename, versionConf)
                GetLogger().WithField("config", versionConf).Debug("Using existing Config")
                return versionConf, vErr
        }</span>
        <span class="cov0" title="0">return versionConf, nil</span>
}

func takeCareAboutRepo(pathTouse string, config configure.GitVersionInfo) configure.GitVersionInfo <span class="cov0" title="0">{
        exists, _ := dirhandle.Exists(getSourcePath(pathTouse))
        if !exists </span><span class="cov0" title="0">{ // source folder not exists
                if config.Repositiory != "" </span><span class="cov0" title="0">{ // no repository info exists
                        createSharedUsageDir(pathTouse) // check if the usage folder exists and create them if not
                        gitCmd := "git clone https://github.com/" + config.Repositiory + ".git " + getSourcePath(pathTouse)
                        GetLogger().WithField("cmd", gitCmd).Info("using git to create new checkout from repo")
                        exec, args := GetExecDefaults()
                        codeInt, codeCmd, err := ExecuteScriptLine(exec, args, gitCmd, func(feed string, e error) bool </span><span class="cov0" title="0">{
                                fmt.Println(feed)
                                return true
                        }</span>, func(process *os.Process) <span class="cov0" title="0">{
                                pidStr := fmt.Sprintf("%d", process.Pid)
                                GetLogger().WithFields(logrus.Fields{"process": pidStr}).Debug("git process id")
                        }</span>)

                        <span class="cov0" title="0">GetLogger().WithFields(logrus.Fields{"codeInternal": codeInt, "code": codeCmd, "err": err}).Debug("git execution result")</span>
                } else<span class="cov0" title="0"> {
                        GetLogger().WithFields(logrus.Fields{"folder": pathTouse}).Debug("source folder exists, but no version info")
                }</span>
        }
        <span class="cov0" title="0">config.Path = getSourcePath(pathTouse)
        return config</span>
}

func writeGitConfig(path string, config configure.GitVersionInfo) error <span class="cov0" title="0">{
        b, _ := json.MarshalIndent(config, "", " ")
        if err := ioutil.WriteFile(path, b, 0644); err != nil </span><span class="cov0" title="0">{
                GetLogger().Error("can not create file ", path, " ", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func loadGitConfig(path string, config configure.GitVersionInfo) (configure.GitVersionInfo, error) <span class="cov0" title="0">{

        file, _ := os.Open(path)
        defer file.Close()
        decoder := json.NewDecoder(file)

        err := decoder.Decode(&amp;config)
        return config, err

}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "bytes"
        "fmt"
        "io/ioutil"

        "os"
        "os/user"
        "strings"

        "github.com/spf13/cobra"

        "github.com/swaros/contxt/dirhandle"
        "github.com/swaros/manout"
)

func UserDirectory() (string, error) <span class="cov0" title="0">{
        usr, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return usr.HomeDir, err</span>
}

func FishUpdate(cmd *cobra.Command) <span class="cov0" title="0">{
        FishFunctionUpdate()
        FishCompletionUpdate(cmd)
}</span>

func FishCompletionUpdate(cmd *cobra.Command) <span class="cov0" title="0">{
        usrDir, err := UserDirectory()
        if err == nil &amp;&amp; usrDir != "" </span><span class="cov0" title="0">{
                // completion dir Exists ?
                exists, err := dirhandle.Exists(usrDir + "/.config/fish/completions")
                if err == nil &amp;&amp; !exists </span><span class="cov0" title="0">{
                        mkErr := os.Mkdir(usrDir+"/.config/fish/completions/", os.ModePerm)
                        if mkErr != nil </span><span class="cov0" title="0">{
                                log.Fatal(mkErr)
                        }</span>
                }
        }
        <span class="cov0" title="0">cmpltn := new(bytes.Buffer)
        cmd.Root().GenFishCompletion(cmpltn, true)

        origin := cmpltn.String()
        ctxCmpltn := strings.ReplaceAll(origin, "contxt", "ctx")
        WriteFileIfNotExists(usrDir+"/.config/fish/completions/contxt.fish", origin)
        WriteFileIfNotExists(usrDir+"/.config/fish/completions/ctx.fish", ctxCmpltn)</span>

}

func WriteFileIfNotExists(filename, content string) (int, error) <span class="cov0" title="0">{
        funcExists, funcErr := dirhandle.Exists(filename)
        if funcErr == nil &amp;&amp; !funcExists </span><span class="cov0" title="0">{
                ioutil.WriteFile(filename, []byte(content), 0644)
                return 0, nil
        }</span> else<span class="cov0" title="0"> if funcExists </span><span class="cov0" title="0">{
                return 1, nil
        }</span>
        <span class="cov0" title="0">return 2, funcErr</span>

}

func FishFunctionUpdate() <span class="cov0" title="0">{

        fishFunc := `function ctx
    contxt $argv
    switch $argv[1]
       case switch
          cd (contxt dir --last)
          contxt dir paths --coloroff --nohints
    end
end`
        cnFunc := `function cn
        cd (contxt dir find $argv)
end`

        usrDir, err := UserDirectory()
        if err == nil &amp;&amp; usrDir != "" </span><span class="cov0" title="0">{
                // functions dir Exists ?
                exists, err := dirhandle.Exists(usrDir + "/.config/fish/functions")
                if err == nil &amp;&amp; !exists </span><span class="cov0" title="0">{
                        mkErr := os.Mkdir(usrDir+"/.config/fish/functions", os.ModePerm)
                        if mkErr != nil </span><span class="cov0" title="0">{
                                log.Fatal(mkErr)
                        }</span>
                }

                <span class="cov0" title="0">funcExists, funcErr := dirhandle.Exists(usrDir + "/.config/fish/functions/ctx.fish")
                if funcErr == nil &amp;&amp; !funcExists </span><span class="cov0" title="0">{
                        ioutil.WriteFile(usrDir+"/.config/fish/functions/ctx.fish", []byte(fishFunc), 0644)
                }</span> else<span class="cov0" title="0"> if funcExists </span><span class="cov0" title="0">{
                        fmt.Println("ctx function already exists. did not change that")
                }</span>

                <span class="cov0" title="0">funcExists, funcErr = dirhandle.Exists(usrDir + "/.config/fish/functions/cn.fish")
                if funcErr == nil &amp;&amp; !funcExists </span><span class="cov0" title="0">{
                        ioutil.WriteFile(usrDir+"/.config/fish/functions/cn.fish", []byte(cnFunc), 0644)
                }</span> else<span class="cov0" title="0"> if funcExists </span><span class="cov0" title="0">{
                        fmt.Println("cn function already exists. did not change that")
                }</span>
        }
}

func BashUser() <span class="cov0" title="0">{
        bashrcAdd := `
### begin contxt bashrc
function cn() { cd $(contxt dir find "$@"); }
function ctx() {        
        contxt "$@";
        [ $? -eq 0 ]  || return 1
        case $1 in
          switch)          
          cd $(contxt dir --last);                  
          contxt dir paths --coloroff --nohints
          ;;
        esac
}
function ctxcompletion() {        
        ORIG=$(contxt completion bash)
        CM="contxt"
        CT="ctx"
        CTXC="${ORIG//$CM/$CT}"
        echo "$CTXC"
}
source &lt;(contxt completion bash)
source &lt;(ctxcompletion)
### end of contxt bashrc
        `
        usrDir, err := UserDirectory()
        if err == nil &amp;&amp; usrDir != "" </span><span class="cov0" title="0">{
                ok, errDh := dirhandle.Exists(usrDir + "/.bashrc")
                if errDh == nil &amp;&amp; ok </span><span class="cov0" title="0">{
                        fmt.Println(usrDir + "/.bashrc")
                        fine, errmsg := updateExistingFile(usrDir+"/.bashrc", bashrcAdd, "### begin contxt bashrc")
                        if !fine </span><span class="cov0" title="0">{
                                manout.Error("bashrc update failed", errmsg)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(manout.MessageCln(manout.ForeGreen, "success", manout.CleanTag, " to update bash run ", manout.ForeCyan, " source ~/.bashrc"))
                        }</span>
                } else<span class="cov0" title="0"> {
                        manout.Error("missing .bashrc", "could not find expected "+usrDir+"/.bashrc")
                }</span>
        }

}

func ZshUpdate(cmd *cobra.Command) <span class="cov0" title="0">{
        ZshUser()
        updateZshFunctions(cmd)
}</span>

// try to get the best path by reading the permission
// because zsh seems not be used in windows, we stick to linux related
// permission check
func ZshFuncDir() string <span class="cov0" title="0">{
        fpath := os.Getenv("FPATH")
        if fpath != "" </span><span class="cov0" title="0">{
                paths := strings.Split(fpath, ":")
                for _, path := range paths </span><span class="cov0" title="0">{
                        fileStats, err := os.Stat(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">permissions := fileStats.Mode().Perm()
                        if permissions&amp;0b110000000 == 0b110000000 </span><span class="cov0" title="0">{
                                return path
                        }</span>
                }
                <span class="cov0" title="0">return ""</span>
        }
        <span class="cov0" title="0">return fpath</span>
}

func updateZshFunctions(cmd *cobra.Command) <span class="cov0" title="0">{
        funcDir := ZshFuncDir()
        if funcDir != "" </span><span class="cov0" title="0">{
                contxtPath := funcDir + "/_contxt"
                ctxPath := funcDir + "/_ctx"
                fmt.Println(funcDir)

                cmpltn := new(bytes.Buffer)
                cmd.Root().GenZshCompletion(cmpltn)

                origin := cmpltn.String()
                ctxCmpltn := strings.ReplaceAll(origin, "contxt", "ctx")

                WriteFileIfNotExists(contxtPath, origin)
                WriteFileIfNotExists(ctxPath, ctxCmpltn)
        }</span> else<span class="cov0" title="0"> {
                manout.Error("could not find a writable path for zsh functions in fpath")
        }</span>
}

func ZshUser() <span class="cov0" title="0">{
        zshrcAdd := `
### begin contxt zshrc
function cn() { cd $(contxt dir find "$@"); }
function ctx() {        
        contxt "$@";
        [ $? -eq 0 ]  || return $?
        case $1 in
          switch)          
          cd $(contxt dir --last);
          contxt dir paths --coloroff --nohints
          ;;
        esac
}
### end of contxt zshrc
        `
        usrDir, err := UserDirectory()
        if err == nil &amp;&amp; usrDir != "" </span><span class="cov0" title="0">{
                ok, errDh := dirhandle.Exists(usrDir + "/.zshrc")
                if errDh == nil &amp;&amp; ok </span><span class="cov0" title="0">{
                        fmt.Println(usrDir + "/.zshrc")
                        fine, errmsg := updateExistingFile(usrDir+"/.zshrc", zshrcAdd, "### begin contxt zshrc")
                        if !fine </span><span class="cov0" title="0">{
                                manout.Error("zshrc update failed", errmsg)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(manout.MessageCln(manout.ForeGreen, "success", manout.CleanTag, "  ", manout.ForeCyan, " "))
                        }</span>
                } else<span class="cov0" title="0"> {
                        manout.Error("missing .zshrc", "could not find expected "+usrDir+"/.zshrc")
                }</span>
        }

}

func updateExistingFile(filename, content, doNotContain string) (bool, string) <span class="cov0" title="0">{
        ok, errDh := dirhandle.Exists(filename)
        errmsg := ""
        if errDh == nil &amp;&amp; ok </span><span class="cov0" title="0">{
                byteCnt, err := ioutil.ReadFile(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return false, "file not readable " + filename
                }</span>
                <span class="cov0" title="0">strContent := string(byteCnt)
                if strings.Contains(strContent, doNotContain) </span><span class="cov0" title="0">{
                        return false, "it seems file is already updated. it contains: " + doNotContain
                }</span> else<span class="cov0" title="0"> {
                        file, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                                return false, "error while opening file " + filename
                        }</span>
                        <span class="cov0" title="0">defer file.Close()
                        if _, err := file.WriteString(content); err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                                return false, "error adding content to file " + filename
                        }</span>
                        <span class="cov0" title="0">return true, ""</span>
                }

        } else<span class="cov0" title="0"> {
                errmsg = "file update error: file not exists " + filename
        }</span>
        <span class="cov0" title="0">return false, errmsg</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "context"
        "errors"
        "strings"
        "sync"
        "time"

        "github.com/swaros/contxt/awaitgroup"
)

var procTracker sync.Map

type TaskRuntimeState struct {
        // flag that will be true if the task is started already. or start is initiated
        Started bool
        // flag that is true if the task is timed out. not equals to Done
        TimedOut bool
        // flag if task is done
        Done bool
        // the runId. equals to the taskname
        RunId string
}

// simple container used to get the result
// from task
type TaskResult struct {
        Error   error
        Content interface{}
}

type TaskWatched struct {
        // current runtime states
        task TaskRuntimeState
        // taskname that should be unique
        taskName string
        // arguments for the task
        TaskArgs map[string]string
        // if true, no error will be raised, if the same task will tried to be executed twice
        NoErrorIfBlocked bool
        // maximum of allowed runtime for the task
        TimeOutTiming time.Duration
        // optional callback. if set, these function is called. that is ment to be informed and for doing some cleanups.
        // but it can not interrupt the timeeout.
        TimeOutHandler func()
        // optional callback. this method can decide, if this task could be started again.
        // so this method will be executed only on the second try to run this task.
        CanRunAgain func(*TaskWatched) bool
        // can be set to define a custom taskid by some logic
        GetRunId func() string
        // the main function that contains the logic
        Exec func(*TaskWatched) TaskResult
        // simple callback that can be used for regular output or loggings
        LoggerFnc func(...interface{})
        // if true, the task will be started async.
        Async bool
        // callback for the execution result
        ResultFnc func(TaskResult)
}

type TaskGroup struct {
        tasks  []TaskWatched
        Awaits []awaitgroup.Future // Future channels
        // simple callback that can be used for regular output or loggings
        LoggerFnc func(...interface{})
}

// helper to creates a task result
func CreateTaskResult(err error) TaskResult <span class="cov0" title="0">{
        return TaskResult{
                Error: err,
        }
}</span>

// helper to creates a task result
func CreateTaskResultContent(err error, content interface{}) TaskResult <span class="cov0" title="0">{
        return TaskResult{
                Error:   err,
                Content: content,
        }
}</span>

func (t *TaskWatched) Init(name string) <span class="cov0" title="0">{
        t.taskName = name
        // if nothing set, we set to 30 minutes.
        // because this is ment to be used in needs (task they are runs for preperations)
        // it can be expected, some of these pre-tasks are time consuming.
        if t.TimeOutTiming == 0 </span><span class="cov0" title="0">{
                t.TimeOutTiming = 30 * time.Minute
        }</span>

        <span class="cov0" title="0">t.TaskArgs = make(map[string]string)
        if t.GetRunId == nil </span><span class="cov0" title="0">{
                t.task.RunId = name
        }</span> else<span class="cov0" title="0"> {
                t.task.RunId = t.GetRunId()
        }</span>
}

func (t *TaskWatched) Log(msg ...interface{}) <span class="cov0" title="0">{
        if t.LoggerFnc != nil </span><span class="cov0" title="0">{
                t.LoggerFnc(msg...)
        }</span>
}

func (t *TaskWatched) trackStart() bool <span class="cov0" title="0">{
        if _, exists := procTracker.Load(t.task.RunId); exists </span><span class="cov0" title="0">{
                // if a decion method defined we ask them.
                // if not we disagree
                if t.CanRunAgain != nil </span><span class="cov0" title="0">{
                        return t.CanRunAgain(t)
                }</span>
                <span class="cov0" title="0">t.Log("&gt;&gt; allready runs ", t.task.RunId)
                return false</span>
        }
        <span class="cov0" title="0">t.task.Started = true
        t.task.Done = false
        t.Log("&gt;&gt; save runtime tracking for task ", t.task.RunId)
        procTracker.Store(t.task.RunId, t.task)
        return true</span>

}

func (t *TaskWatched) IsRunning() bool <span class="cov0" title="0">{
        if t.task.Done </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if task, exists := procTracker.Load(t.task.RunId); exists </span><span class="cov0" title="0">{
                var taskSet TaskRuntimeState = task.(TaskRuntimeState)
                if taskSet.Done </span><span class="cov0" title="0">{
                        return false
                }</span>

        }
        <span class="cov0" title="0">return true</span>

}

func (t *TaskWatched) ReportDone() <span class="cov0" title="0">{
        if task, exists := procTracker.Load(t.task.RunId); exists </span><span class="cov0" title="0">{
                var taskSet TaskRuntimeState = task.(TaskRuntimeState)
                if taskSet.Done </span><span class="cov0" title="0">{
                        t.Log("&lt;&gt; Task ", t.taskName, " was already set to DONE")
                        return
                }</span>
                <span class="cov0" title="0">taskSet.Done = true
                t.Log("&lt;&lt; Update Task. Set ", t.taskName, " DONE")
                procTracker.Store(taskSet.RunId, taskSet)</span>
        } else<span class="cov0" title="0"> {
                t.task.Done = true
                t.Log("&lt;&lt; Update Task ", t.taskName, " NOT EXISTS ")
        }</span>
}

func (t *TaskWatched) Run() TaskResult <span class="cov0" title="0">{
        t.Log("&gt;&gt; run func \t", t.taskName, " id ", t.task.RunId)
        var taskRes TaskResult
        if t.Exec == nil </span><span class="cov0" title="0">{
                t.ReportDone()
                taskRes.Error = errors.New("body function exec is undefined")
                return taskRes
        }</span>
        // starting the body function and track the execution
        // first we check if can start the task
        <span class="cov0" title="0">if !t.trackStart() </span><span class="cov0" title="0">{
                if t.NoErrorIfBlocked </span><span class="cov0" title="0">{
                        return taskRes
                }</span>
                <span class="cov0" title="0">taskRes.Error = errors.New("task is already running")
                return taskRes</span>
        }

        <span class="cov0" title="0">time.AfterFunc(t.TimeOutTiming, func() </span><span class="cov0" title="0">{

                t.Log("&gt;&gt; timeout reached on task ", t.taskName, " was set to ", t.TimeOutTiming)
                // there is no decsion alowed. timed out task
                // would not be executed.
                // a defined timeOut callback is just
                // ment for cleanup
                if t.TimeOutHandler != nil </span><span class="cov0" title="0">{
                        t.TimeOutHandler()
                }</span>
                // update task info
                <span class="cov0" title="0">if task, exists := procTracker.Load(t.task.RunId); exists </span><span class="cov0" title="0">{
                        var taskDef TaskRuntimeState = task.(TaskRuntimeState)
                        taskDef.TimedOut = true
                        procTracker.Store(t.task.RunId, taskDef)
                }</span>

        })

        <span class="cov0" title="0">defer t.ReportDone()
        res := t.Exec(t)
        if t.ResultFnc != nil </span><span class="cov0" title="0">{
                t.ResultFnc(res)
        }</span>
        <span class="cov0" title="0">return res</span>
}

func (t *TaskWatched) GetName() string <span class="cov0" title="0">{
        return t.taskName
}</span>

func CreateMultipleTask(tasks []string, modifyTask func(*TaskWatched)) *TaskGroup <span class="cov0" title="0">{
        var taskGrp TaskGroup
        for _, task := range tasks </span><span class="cov0" title="0">{
                newTask := TaskWatched{
                        taskName: task,
                }
                newTask.Init(task)
                modifyTask(&amp;newTask)
                taskGrp.tasks = append(taskGrp.tasks, newTask)
        }</span>
        <span class="cov0" title="0">return &amp;taskGrp</span>
}

func (Tg *TaskGroup) GetTask(name string) (bool, TaskWatched) <span class="cov0" title="0">{
        for _, tw := range Tg.tasks </span><span class="cov0" title="0">{
                if strings.EqualFold(tw.taskName, name) </span><span class="cov0" title="0">{
                        return true, tw
                }</span>
        }
        <span class="cov0" title="0">return false, TaskWatched{}</span>
}

func (Tg *TaskGroup) AddTask(name string, wg TaskWatched) *TaskGroup <span class="cov0" title="0">{
        wg.Init(name)
        Tg.tasks = append(Tg.tasks, wg)
        return Tg
}</span>

func (Tg *TaskGroup) Exec() *TaskGroup <span class="cov0" title="0">{

        var tasks []awaitgroup.FutureStack
        for _, tsk := range Tg.tasks </span><span class="cov0" title="0">{
                tsk.Log("add task function ", tsk.taskName)
                tasks = append(tasks, awaitgroup.FutureStack{
                        AwaitFunc: func(_ context.Context) interface{} </span><span class="cov0" title="0">{
                                res := tsk.Run()
                                return res.Content
                        }</span>, Argument: tsk.taskName})
        }
        <span class="cov0" title="0">Tg.Awaits = awaitgroup.ExecFutureGroup(tasks)
        return Tg</span>
}

func (Tg *TaskGroup) Log(msg ...interface{}) <span class="cov0" title="0">{
        if Tg.LoggerFnc != nil </span><span class="cov0" title="0">{
                Tg.LoggerFnc(msg...)
        }</span>
}

// Wait until all task are done, indepenet from any channel and waitgroup blocks
func (Tg *TaskGroup) Wait(wait time.Duration, timeOut time.Duration) <span class="cov0" title="0">{
        GetLogger().Debug("wait ... start")
        awaitgroup.WaitAtGroup(Tg.Awaits)
        GetLogger().Debug("wait ... start")
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

var watchTaskList sync.Map

// TaskDef holds information about running
// and finished tasks
type TaskDef struct {
        started   bool
        count     int
        done      bool
        doneCount int
}

func incTaskCount(target string) <span class="cov8" title="1">{
        taskInfo, _ := getTask(target)
        taskInfo.count++
        watchTaskList.Store(target, taskInfo)
}</span>

func incTaskDoneCount(target string) bool <span class="cov8" title="1">{
        taskInfo, exists := getTask(target)
        if !exists </span><span class="cov0" title="0">{
                GetLogger().Fatal("can not handle task they never started")
                return false
        }</span>
        <span class="cov8" title="1">taskInfo.doneCount++
        taskInfo.done = taskInfo.doneCount == taskInfo.count
        watchTaskList.Store(target, taskInfo)
        return taskInfo.done</span>

}

// ResetAllTaskInfos resets all task infos
func ResetAllTaskInfos() <span class="cov8" title="1">{
        watchTaskList.Range(func(key, _ interface{}) bool </span><span class="cov8" title="1">{
                watchTaskList.Delete(key)
                return true
        }</span>)
}

// TaskExists checks if a task is already created
func TaskExists(target string) bool <span class="cov0" title="0">{
        _, found := watchTaskList.Load(target)
        return found
}</span>

// TaskRunning checks if a task is already running
func TaskRunning(target string) bool <span class="cov8" title="1">{
        info, found := watchTaskList.Load(target)
        return found &amp;&amp; info != nil &amp;&amp; info.(TaskDef).count &gt; 0 &amp;&amp; info.(TaskDef).count != info.(TaskDef).doneCount
}</span>

// checks if a task was at least started X times
func TaskRunsAtLeast(target string, atLeast int) bool <span class="cov8" title="1">{
        if info, found := watchTaskList.Load(target); found </span><span class="cov8" title="1">{
                return info.(TaskDef).count &gt;= atLeast
        }</span>
        <span class="cov8" title="1">return false</span>
}

// WaitForTasksDone waits until all the task are done
// triggers a callback for any tick
// and one if the state DONE is reached
// there is an timeout as maximum time to wait
// if this time is reached the process will be continued
// and the timeout callback is triggered
// the callback for notStarted must return true if they handle this issue.
// on returning false it will be counted as isDone
func WaitForTasksDone(tasks []string, timeOut, tickTime time.Duration, stillWait func() bool, isDone func(), timeOutHandle func(), notStartet func(string, string, map[string]string) bool) <span class="cov8" title="1">{
        running := true
        allDone := false
        for running </span><span class="cov8" title="1">{
                doneCount := 0
                for _, targetFullName := range tasks </span><span class="cov8" title="1">{
                        targetName, args := StringSplitArgs(targetFullName, "arg")
                        taskInfo, found := watchTaskList.Load(targetName)
                        GetLogger().WithField("task", targetFullName).Trace("checking taskWait for needs")
                        if !found &amp;&amp; !notStartet(targetFullName, targetName, args) </span><span class="cov8" title="1">{
                                GetLogger().WithField("task", targetFullName).Error("could not check against task that was never started")
                                doneCount++
                        }</span>
                        <span class="cov8" title="1">if found &amp;&amp; taskInfo.(TaskDef).done </span><span class="cov0" title="0">{
                                doneCount++
                        }</span>
                }

                <span class="cov8" title="1">if doneCount &gt; len(tasks) </span><span class="cov0" title="0">{
                        GetLogger().WithField("tasks", tasks).Fatal("Unexpected count of task reported. taskWatcher seems broken")
                }</span>

                <span class="cov8" title="1">if doneCount == len(tasks) </span><span class="cov8" title="1">{
                        GetLogger().WithFields(logrus.Fields{"tasks": tasks, "doneCount": doneCount, "taskCount": len(tasks)}).Info("Task-wait-check done regular")
                        allDone = true
                        isDone()
                        return
                }</span>
                <span class="cov8" title="1">if stillWait() </span><span class="cov8" title="1">{
                        GetLogger().WithField("sleep", tickTime).Info("Task-wait-check waiting")
                        time.Sleep(tickTime)
                }</span> else<span class="cov0" title="0"> {
                        GetLogger().WithField("tasks", tasks).Info("Task-wait-check done by abort. stillWait() will no longer wait")
                        allDone = true
                        isDone()
                        return
                }</span>
                <span class="cov8" title="1">time.AfterFunc(timeOut, func() </span><span class="cov8" title="1">{
                        if !allDone </span><span class="cov8" title="1">{
                                GetLogger().WithField("tasks", tasks).Warning("Task-wait-check running in Timeout-Check.")
                                GetLogger().WithFields(logrus.Fields{
                                        "timeOut":   timeOut,
                                        "doneFlag":  allDone,
                                        "tasks":     tasks,
                                        "doneCount": doneCount,
                                        "taskCount": len(tasks)}).Info("timeout variables")
                                timeOutHandle()
                        }</span>
                        <span class="cov8" title="1">running = false</span>
                })
        }
}

func getTask(target string) (TaskDef, bool) <span class="cov8" title="1">{
        taskInfo, found := watchTaskList.Load(target)
        if found &amp;&amp; taskInfo != nil </span><span class="cov8" title="1">{
                return taskInfo.(TaskDef), true
        }</span>
        <span class="cov8" title="1">nwTask := TaskDef{
                count:     0,
                done:      false,
                doneCount: 0,
                started:   false,
        }
        watchTaskList.Store(target, nwTask)
        return nwTask, false</span>

}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "errors"
        "io/ioutil"
        "os"

        "github.com/sirupsen/logrus"
        "gopkg.in/yaml.v2"
)

// CreateImport creates import settings
func CreateImport(path string, pathToAdd string) error <span class="cov0" title="0">{
        importTemplate, pathToFile, fullPath, existing := getIncludeConfig(path)

        _, ferr := os.Stat(pathToAdd)
        if ferr != nil </span><span class="cov0" title="0">{
                return ferr
        }</span>

        <span class="cov0" title="0">GetLogger().WithFields(logrus.Fields{
                "exists": existing,
                "path":   pathToFile,
                "folder": fullPath,
                "add":    pathToAdd,
        }).Debug("read imports")

        for _, existingPath := range importTemplate.Include.Folders </span><span class="cov0" title="0">{
                if existingPath == pathToAdd </span><span class="cov0" title="0">{
                        err1 := errors.New("path already exists")
                        return err1
                }</span>
        }

        <span class="cov0" title="0">importTemplate.Include.Folders = append(importTemplate.Include.Folders, pathToAdd)
        res, err := yaml.Marshal(importTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ioutil.WriteFile(pathToFile, []byte(res), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "os/user"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/imdario/mergo"

        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/dirhandle"
        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"
        "gopkg.in/yaml.v2"
)

const (
        incFileParseError  = 105
        mainFileParseError = 104
)

// FindTemplate searchs for Template files in different spaces
func FindTemplate() (string, bool) <span class="cov8" title="1">{
        // 1. looking in user mirror path
        usr, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                GetLogger().Fatal(err)
        }</span>

        <span class="cov8" title="1">homeDirYml := usr.HomeDir + configure.DefaultPath + configure.MirrorPath + DefaultExecYaml
        exists, exerr := dirhandle.Exists(homeDirYml)
        if exerr == nil &amp;&amp; exists </span><span class="cov0" title="0">{
                return homeDirYml, true
        }</span>

        // 2. looking in current path with user name as prefix
        <span class="cov8" title="1">dir, curerr := dirhandle.Current()
        if curerr == nil </span><span class="cov8" title="1">{
                userYml := dir + string(os.PathSeparator) + usr.Username + defaultExecYamlName
                exists, exerr = dirhandle.Exists(userYml)
                if exerr == nil &amp;&amp; exists </span><span class="cov0" title="0">{
                        return userYml, true
                }</span>

                // 3. plain template in current dir
                <span class="cov8" title="1">regularPath := dir + DefaultExecYaml
                exists, exerr = dirhandle.Exists(regularPath)
                if exerr == nil &amp;&amp; exists </span><span class="cov8" title="1">{
                        return regularPath, true
                }</span>
        }

        <span class="cov0" title="0">return "", false</span>
}

// GetTemplate return current template, the absolute path,if it exists, any error
func GetTemplate() (configure.RunConfig, string, bool, error) <span class="cov8" title="1">{

        foundPath, success := FindTemplate()
        var template configure.RunConfig
        if !success </span><span class="cov0" title="0">{
                return template, "", false, errors.New("template not found or have failures")
        }</span>
        <span class="cov8" title="1">ctemplate, err := GetPwdTemplate(foundPath)
        if err == nil </span><span class="cov8" title="1">{
                // checking required shared templates
                // and merge them into the current template
                if len(ctemplate.Config.Require) &gt; 0 </span><span class="cov0" title="0">{
                        for _, reqSource := range ctemplate.Config.Require </span><span class="cov0" title="0">{
                                GetLogger().WithField("path", reqSource).Debug("handle required ")
                                fullPath, pathError := CheckOrCreateUseConfig(reqSource)
                                if pathError == nil </span><span class="cov0" title="0">{
                                        GetLogger().WithField("path", fullPath).Info("require path resolved")
                                        subTemplate, tError := GetPwdTemplate(fullPath + string(os.PathSeparator) + DefaultExecYaml)
                                        if tError == nil </span><span class="cov0" title="0">{
                                                mergo.Merge(&amp;ctemplate, subTemplate, mergo.WithOverride, mergo.WithAppendSlice)
                                                GetLogger().WithField("template", ctemplate).Debug("merged")
                                        }</span> else<span class="cov0" title="0"> {
                                                return template, "", false, tError
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return template, "", false, pathError
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        GetLogger().Debug("no required files configured")
                }</span>

                <span class="cov8" title="1">return ctemplate, foundPath, true, nil</span>
        }

        <span class="cov0" title="0">return template, "", false, err</span>
}

func getIncludeConfigPath(path string) (string, string, bool) <span class="cov8" title="1">{
        fullPath := filepath.Dir(path)
        checkIncPath := fullPath + string(os.PathSeparator) + ".inc.contxt.yml"
        existing, fileerror := dirhandle.Exists(checkIncPath)
        if fileerror != nil || !existing </span><span class="cov8" title="1">{
                return checkIncPath, fullPath, false
        }</span>
        <span class="cov8" title="1">GetLogger().WithField("include-config", checkIncPath).Debug("found include setting")
        return checkIncPath, fullPath, true</span>
}

func getIncludeConfig(path string) (configure.IncludePaths, string, string, bool) <span class="cov8" title="1">{
        var importTemplate configure.IncludePaths
        checkIncPath, fullPath, existing := getIncludeConfigPath(path)
        if !existing </span><span class="cov8" title="1">{
                return importTemplate, checkIncPath, fullPath, false
        }</span>

        <span class="cov8" title="1">file, ferr := ioutil.ReadFile(checkIncPath)
        if ferr != nil </span><span class="cov0" title="0">{
                return importTemplate, checkIncPath, fullPath, false
        }</span>
        <span class="cov8" title="1">err := yaml.Unmarshal(file, &amp;importTemplate)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln(manout.ForeRed, "error reading include config file: ", manout.ForeWhite, checkIncPath), err)
                systools.Exit(incFileParseError)
        }</span>
        <span class="cov8" title="1">return importTemplate, checkIncPath, fullPath, true</span>
}

// LoadIncTempalte check if .inc.contxt.yml files exists
// and if this is the case the content will be loaded and all defined paths
// used to get values for parsing the template file
func LoadIncTempalte(path string) (string, bool) <span class="cov8" title="1">{
        importTemplate, _, fullPath, existing := getIncludeConfig(path)
        if !existing </span><span class="cov8" title="1">{
                return "", false
        }</span>
        // imports by Include.Folders
        <span class="cov8" title="1">if len(importTemplate.Include.Folders) &gt; 0 || importTemplate.Include.Basedir </span><span class="cov8" title="1">{
                GetLogger().WithField("file", path).Info("parsing task-file")
                var dirs []string = importTemplate.Include.Folders
                if importTemplate.Include.Basedir </span><span class="cov0" title="0">{
                        GetLogger().WithField("dir", fullPath).Debug("add parsing source dir")
                        dirs = append(dirs, fullPath)
                }</span>

                <span class="cov8" title="1">parsedTemplate, perr := ImportFolders(path, dirs...)
                if perr != nil </span><span class="cov0" title="0">{
                        fmt.Println(perr)
                        fmt.Println(manout.MessageCln(manout.ForeRed, "error parsing files from path: ", manout.ForeWhite, path), perr)
                        systools.Exit(incFileParseError)
                }</span>
                <span class="cov8" title="1">return parsedTemplate, true</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// GetParsedTemplateSource Returns the soucecode of the template
// including parsing placeholders
func GetParsedTemplateSource(path string) (string, error) <span class="cov8" title="1">{
        existing, fileerror := dirhandle.Exists(path)
        if fileerror != nil </span><span class="cov0" title="0">{
                return "", fileerror
        }</span>
        <span class="cov8" title="1">if existing </span><span class="cov8" title="1">{
                // first check if includes exists
                templateSource, inExists := LoadIncTempalte(path)
                if inExists </span><span class="cov8" title="1">{
                        return templateSource, nil
                }</span>
                // no imports .... load template file
                <span class="cov8" title="1">file, ferr := ioutil.ReadFile(path)
                if ferr != nil </span><span class="cov0" title="0">{
                        return "", ferr
                }</span>
                <span class="cov8" title="1">return string(file), nil</span>
        }
        <span class="cov0" title="0">notExistsErr := errors.New("file not exists")
        return "", notExistsErr</span>
}

// GetPwdTemplate returns the template path if exists.
// it also parses the content of the template
// against imports and handles them
func GetPwdTemplate(path string) (configure.RunConfig, error) <span class="cov8" title="1">{
        var template configure.RunConfig
        source, err := GetParsedTemplateSource(path)
        if err != nil </span><span class="cov0" title="0">{
                return template, err
        }</span>

        <span class="cov8" title="1">err2 := yaml.Unmarshal([]byte(source), &amp;template)

        if err2 != nil </span><span class="cov0" title="0">{
                printErrSource(err2, source)
                return template, err2
        }</span>
        <span class="cov8" title="1">return template, nil</span>
}

func getLineNr(str string) (int, error) <span class="cov0" title="0">{
        re := regexp.MustCompile("[0-9]+")
        found := re.FindAllString(str, -1)
        if len(found) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.Atoi(found[0])
        }</span>
        <span class="cov0" title="0">return -1, errors.New("no line number found in message " + str)</span>
}

func printErrSource(err error, source string) <span class="cov0" title="0">{
        errPlain := err.Error()
        errParts := strings.Split(errPlain, ":")

        if len(errParts) == 3 </span><span class="cov0" title="0">{ // this is depending an regular error message from yaml. like: yaml: line 3: mapping values are not allowed in this context
                if lineNr, lErr := getLineNr(errParts[1]); lErr == nil </span><span class="cov0" title="0">{
                        sourceParts := strings.Split(source, "\n")
                        if len(sourceParts) &gt;= lineNr &amp;&amp; lineNr &gt;= 0 </span><span class="cov0" title="0">{
                                min := lineNr - 3
                                max := lineNr + 3
                                if min &lt; 0 </span><span class="cov0" title="0">{
                                        min = 0
                                }</span>
                                <span class="cov0" title="0">if max &gt; len(sourceParts) </span><span class="cov0" title="0">{
                                        max = len(sourceParts)
                                }</span>
                                <span class="cov0" title="0">for i := min; i &lt; max; i++ </span><span class="cov0" title="0">{
                                        nrback := manout.BackWhite
                                        nrFore := manout.ForeBlue
                                        msgFore := manout.ForeCyan
                                        msgBack := ""
                                        msg := ""
                                        if i == lineNr </span><span class="cov0" title="0">{
                                                nrback = manout.BackLightRed
                                                nrFore = manout.ForeRed
                                                msgFore = manout.ForeWhite
                                                msgBack = manout.BackRed
                                                msg = errParts[2]
                                        }</span>

                                        <span class="cov0" title="0">padLineNr := fmt.Sprintf("%4d |", i)
                                        outstr := manout.MessageCln(
                                                nrback,
                                                nrFore,
                                                " ",
                                                padLineNr,
                                                manout.CleanTag,
                                                msgFore,
                                                msgBack,
                                                sourceParts[i],
                                                manout.CleanTag,
                                                manout.ForeLightYellow,
                                                " ",
                                                msg)

                                        fmt.Println(outstr)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                fmt.Println("source parsing faliure", sourceParts)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println(lErr)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("unexpected message format ", len(errParts), " ", errParts)
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package taskrun

import (
        "encoding/json"
        "sync"

        "github.com/sirupsen/logrus"

        "github.com/tidwall/gjson"
)

var dataStorage sync.Map

// AddData adds a Data Map to the storage
func AddData(key string, data map[string]interface{}) <span class="cov8" title="1">{
        dataStorage.Store(key, data)
}</span>

// ImportDataFromJSONFile imports a map from a json file and assign it to a key
func ImportDataFromJSONFile(key string, filename string) error <span class="cov8" title="1">{
        data, err := ImportJSONFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">GetLogger().WithFields(logrus.Fields{"key": key, "file": filename, "value": data}).Trace("variables import")
        AddData(key, data)
        return nil</span>
}

// GetJSONPathValueString returns the value depending key and path as string
func GetJSONPathValueString(key, path string) string <span class="cov8" title="1">{
        ok, data := GetData(key)
        if ok &amp;&amp; data != nil </span><span class="cov8" title="1">{
                jsonData, err := json.Marshal(data)
                if err == nil </span><span class="cov8" title="1">{
                        value := gjson.Get(string(jsonData), path)
                        GetLogger().WithFields(logrus.Fields{"key": key, "path": path, "value": value}).Debug("placeholder: found map entrie")
                        return value.String()
                }</span>
                <span class="cov0" title="0">GetLogger().WithField("key", key).Error("placeholder: error while marshal data")</span>
        } else<span class="cov0" title="0"> {
                GetLogger().WithField("key", key).Error("placeholder: error by getting data from named map")
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetJSONPathResult returns the value depending key and path as string
func GetJSONPathResult(key, path string) (gjson.Result, bool) <span class="cov8" title="1">{
        ok, data := GetData(key)
        if ok &amp;&amp; data != nil </span><span class="cov8" title="1">{
                //mapdata := make(map[string]interface{})
                jsonData, err := json.Marshal(data)
                if err == nil </span><span class="cov8" title="1">{
                        value := gjson.Get(string(jsonData), path)
                        GetLogger().WithFields(logrus.Fields{
                                "key":   key,
                                "path":  path,
                                "value": value.Value()}).Debug("GetJSONPathResult: found map entrie")
                        return value, true
                }</span>
                <span class="cov0" title="0">GetLogger().WithField("key", key).Error("GetJSONPathResult: error while marshal data")</span>
        } else<span class="cov0" title="0"> {
                GetLogger().WithField("key", key).Error("GetJSONPathResult: error by getting data from named map")
        }</span>
        <span class="cov0" title="0">return gjson.Result{
                Index: 0,
        }, false</span>
}

// ImportDataFromYAMLFile imports a map from a json file and assign it to a key
func ImportDataFromYAMLFile(key string, filename string) error <span class="cov8" title="1">{
        data, err := ImportYAMLFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">AddData(key, data)
        return nil</span>
}

// AddJSON imports data by a json String
func AddJSON(key, jsonString string) error <span class="cov8" title="1">{
        m := make(map[string]interface{})
        err := json.Unmarshal([]byte(jsonString), &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">AddData(key, m)
        return nil</span>
}

// GetData returns a data Map by the key.
// or nil if nothing is stored
func GetData(key string) (bool, map[string]interface{}) <span class="cov8" title="1">{
        result, ok := dataStorage.Load(key)
        if ok </span><span class="cov8" title="1">{
                return ok, result.(map[string]interface{})
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

// ClearAllData removes all entries
func ClearAllData() <span class="cov0" title="0">{
        dataStorage.Range(func(key, _ interface{}) bool </span><span class="cov0" title="0">{
                dataStorage.Delete(key)
                return true
        }</span>)
}

// GetDataKeys returns all current keys
func GetDataKeys() []string <span class="cov8" title="1">{
        var keys []string
        dataStorage.Range(func(key, _ interface{}) bool </span><span class="cov8" title="1">{
                keys = append(keys, key.(string))
                return true
        }</span>)
        <span class="cov8" title="1">return keys</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package taskrun

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "text/template"

        "github.com/imdario/mergo"
        "github.com/tidwall/gjson"

        "github.com/swaros/contxt/configure"
        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"

        "github.com/sirupsen/logrus"

        "github.com/Masterminds/sprig/v3"
        "github.com/ghodss/yaml"
)

const (
        inlineCmdSep    = " "
        startMark       = "#@"
        inlineMark      = "#@-"
        iterateMark     = "#@foreach"
        endMark         = "#@end"
        fromJSONMark    = "#@import-json"
        fromJSONCmdMark = "#@import-json-exec"
        parseVarsMark   = "#@var"
        setvarMark      = "#@set"
        addvarMark      = "#@add"
        equalsMark      = "#@if-equals"
        notEqualsMark   = "#@if-not-equals"
        osCheck         = "#@if-os"
        codeLinePH      = "__LINE__"
        codeKeyPH       = "__KEY__"
)

// TryParse to parse a line and set a value depending on the line command
func TryParse(script []string, regularScript func(string) (bool, int)) (bool, int, []string) <span class="cov8" title="1">{
        inIteration := false
        inIfState := false
        ifState := true
        var iterationLines []string
        var parsedScript []string
        var iterationCollect gjson.Result
        for _, line := range script </span><span class="cov8" title="1">{
                line = HandlePlaceHolder(line)
                if len(line) &gt; len(startMark) &amp;&amp; line[0:len(startMark)] == startMark </span><span class="cov8" title="1">{
                        //parts := strings.Split(line, inlineCmdSep)
                        parts := SplitQuoted(line, inlineCmdSep)

                        GetLogger().WithField("keywords", parts).Debug("try to parse parts")
                        if len(parts) &lt; 1 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">switch parts[0] </span>{

                        case osCheck:<span class="cov8" title="1">
                                if !inIfState </span><span class="cov8" title="1">{
                                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                                leftEq := parts[1]
                                                rightEq := configure.GetOs()
                                                inIfState = true
                                                ifState = leftEq == rightEq
                                        }</span> else<span class="cov0" title="0"> {
                                                manout.Error("invalid usage ", equalsMark, " need: str1 str2 ")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage ", equalsMark, " can not be used in another if")
                                }</span>

                        case equalsMark:<span class="cov8" title="1">
                                if !inIfState </span><span class="cov8" title="1">{
                                        if len(parts) == 3 </span><span class="cov8" title="1">{
                                                leftEq := parts[1]
                                                rightEq := parts[2]
                                                inIfState = true
                                                ifState = leftEq == rightEq
                                                GetLogger().WithFields(logrus.Fields{"condition": ifState, "left": leftEq, "right": rightEq}).Debug(equalsMark)
                                        }</span> else<span class="cov0" title="0"> {
                                                manout.Error("invalid usage ", equalsMark, " need: str1 str2 (got:", len(parts), ")")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage ", equalsMark, " can not be used in another if")
                                }</span>

                        case notEqualsMark:<span class="cov0" title="0">
                                if !inIfState </span><span class="cov0" title="0">{
                                        if len(parts) == 3 </span><span class="cov0" title="0">{
                                                leftEq := parts[1]
                                                rightEq := parts[2]
                                                inIfState = true
                                                ifState = leftEq != rightEq
                                                GetLogger().WithFields(logrus.Fields{"condition": ifState, "left": leftEq, "right": rightEq}).Debug(notEqualsMark)
                                        }</span> else<span class="cov0" title="0"> {
                                                manout.Error("invalid usage ", notEqualsMark, " need: str1 str2 (got:", len(parts), ")")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage ", equalsMark, " can not be used in another if")
                                }</span>

                        case inlineMark:<span class="cov8" title="1">
                                if inIteration </span><span class="cov8" title="1">{
                                        iterationLines = append(iterationLines, strings.Replace(line, inlineMark+" ", "", 4))
                                        GetLogger().WithField("code", iterationLines).Debug("append to subscript")
                                }</span> else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage", inlineMark, " only valid while in iteration")
                                }</span>

                        case fromJSONMark:<span class="cov8" title="1">
                                if len(parts) == 3 </span><span class="cov8" title="1">{
                                        err := AddJSON(parts[1], parts[2])
                                        if err != nil </span><span class="cov0" title="0">{
                                                manout.Error("import from json string failed", parts[2], err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage", fromJSONMark, " needs 2 arguments. &lt;keyname&gt; &lt;json-source&gt;")
                                }</span>

                        case fromJSONCmdMark:<span class="cov8" title="1">
                                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                                        returnValue := ""
                                        restSlice := parts[2:]
                                        keyname := parts[1]
                                        cmd := strings.Join(restSlice, " ")
                                        GetLogger().WithFields(logrus.Fields{"key": keyname, "cmd": restSlice}).Info("execute for import-json-exec")
                                        //GetLogger().WithField("slice", restSlice).Info("execute for import-json-exec")
                                        exec, args := GetExecDefaults()
                                        execCode, realExitCode, execErr := ExecuteScriptLine(exec, args, cmd, func(output string, e error) bool </span><span class="cov8" title="1">{
                                                returnValue = returnValue + output
                                                GetLogger().WithField("cmd-output", output).Info("result of command")
                                                return true
                                        }</span>, func(proc *os.Process) <span class="cov8" title="1">{
                                                GetLogger().WithField("import-json-proc", proc).Trace("import-json-process")
                                        }</span>)

                                        <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                                                GetLogger().WithFields(logrus.Fields{
                                                        "intern":       execCode,
                                                        "process-exit": realExitCode,
                                                        "key":          keyname,
                                                        "cmd":          restSlice}).Error("execute for import-json-exec failed")
                                        }</span> else<span class="cov8" title="1"> {

                                                err := AddJSON(keyname, returnValue)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        GetLogger().WithField("error-on-parsing-string", returnValue).Debug("result of command")
                                                        manout.Error("import from json string failed", err, ' ', returnValue)
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage", fromJSONCmdMark, " needs 2 arguments at least. &lt;keyname&gt; &lt;bash-command&gt;")
                                }</span>
                        case addvarMark:<span class="cov8" title="1">
                                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                        setKeyname := parts[1]
                                        setValue := strings.Join(parts[2:], " ")
                                        if ok := AppendToPH(setKeyname, HandlePlaceHolder(setValue)); !ok </span><span class="cov0" title="0">{
                                                manout.Error("variable must exists for add ", addvarMark, " ", setKeyname)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage", setvarMark, " needs 2 arguments at least. &lt;keyname&gt; &lt;value&gt;")
                                }</span>
                        case setvarMark:<span class="cov8" title="1">
                                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                        setKeyname := parts[1]
                                        setValue := strings.Join(parts[2:], " ")
                                        SetPH(setKeyname, HandlePlaceHolder(setValue))
                                }</span> else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage", setvarMark, " needs 2 arguments at least. &lt;keyname&gt; &lt;value&gt;")
                                }</span>
                        case parseVarsMark:<span class="cov8" title="1">
                                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                        var returnValues []string
                                        restSlice := parts[2:]
                                        cmd := strings.Join(restSlice, " ")
                                        exec, args := GetExecDefaults()
                                        internalCode, cmdCode, errorFromCm := ExecuteScriptLine(exec, args, cmd, func(output string, e error) bool </span><span class="cov8" title="1">{
                                                if e == nil </span><span class="cov8" title="1">{
                                                        returnValues = append(returnValues, output)
                                                }</span>
                                                <span class="cov8" title="1">return true</span>

                                        }, func(proc *os.Process) <span class="cov8" title="1">{
                                                GetLogger().WithField(parseVarsMark, proc).Trace("sub process")
                                        }</span>)

                                        <span class="cov8" title="1">if internalCode == ExitOk &amp;&amp; errorFromCm == nil &amp;&amp; cmdCode == 0 </span><span class="cov8" title="1">{
                                                GetLogger().WithField("values", returnValues).Trace("got values")
                                                SetPH(parts[1], HandlePlaceHolder(strings.Join(returnValues, "\n")))
                                        }</span> else<span class="cov0" title="0"> {
                                                GetLogger().WithFields(logrus.Fields{
                                                        "returnCode": cmdCode,
                                                        "error":      errorFromCm.Error,
                                                }).Error("subcommand failed.")
                                                manout.Error("Subcommand failed", cmd, " ... was used to get json context. ", errorFromCm.Error())
                                                manout.Error("cmd:", exec, "  ", args, " ", cmd)
                                        }</span>

                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid usage", parseVarsMark, " needs 2 arguments at least. &lt;varibale-name&gt; &lt;bash-command&gt;")
                                }</span>

                        case endMark:<span class="cov8" title="1">

                                if inIfState </span><span class="cov8" title="1">{
                                        GetLogger().Debug("IF: DONE")
                                        inIfState = false
                                        ifState = true
                                }</span>
                                <span class="cov8" title="1">if inIteration </span><span class="cov8" title="1">{
                                        GetLogger().Debug("ITERATION: DONE")
                                        inIteration = false
                                        abortFound := false
                                        returnCode := ExitOk

                                        iterationCollect.ForEach(func(key gjson.Result, value gjson.Result) bool </span><span class="cov8" title="1">{
                                                var parsedExecLines []string
                                                for _, iLine := range iterationLines </span><span class="cov8" title="1">{
                                                        iLine = strings.Replace(iLine, codeLinePH, value.String(), 1)
                                                        iLine = strings.Replace(iLine, codeKeyPH, key.String(), 1)
                                                        parsedExecLines = append(parsedExecLines, iLine)
                                                }</span>
                                                <span class="cov8" title="1">GetLogger().WithFields(logrus.Fields{
                                                        "key":       key,
                                                        "value":     value,
                                                        "subscript": parsedExecLines,
                                                }).Debug("... delegate script")
                                                abort, rCode, subs := TryParse(parsedExecLines, regularScript)
                                                returnCode = rCode
                                                parsedScript = append(parsedScript, subs...)

                                                if abort </span><span class="cov8" title="1">{
                                                        abortFound = true
                                                        return false
                                                }</span>
                                                <span class="cov8" title="1">return true</span>
                                        })

                                        <span class="cov8" title="1">if abortFound </span><span class="cov8" title="1">{
                                                return true, returnCode, parsedScript
                                        }</span>
                                }

                        case iterateMark:<span class="cov8" title="1">
                                if len(parts) == 3 </span><span class="cov8" title="1">{
                                        impMap, found := GetJSONPathResult(parts[1], parts[2])
                                        if !found </span><span class="cov0" title="0">{
                                                manout.Error("undefined data from path", parts[1], parts[2])
                                        }</span> else<span class="cov8" title="1"> {
                                                inIteration = true
                                                iterationCollect = impMap
                                                GetLogger().WithField("data", impMap).Debug("ITERATION: START")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        manout.Error("invalid arguments", "#@iterate needs &lt;name-of-import&gt; &lt;path-to-data&gt;")
                                }</span>
                        default:<span class="cov0" title="0">
                                GetLogger().WithField("unknown", parts[0]).Error("there is no command exists")</span>
                        }
                } else<span class="cov8" title="1"> {
                        parsedScript = append(parsedScript, line)
                        // execute the *real* script lines
                        if ifState </span><span class="cov8" title="1">{
                                abort, returnCode := regularScript(line)
                                if abort </span><span class="cov8" title="1">{
                                        return true, returnCode, parsedScript
                                }</span>
                        } else<span class="cov8" title="1"> {
                                GetLogger().WithField("code", line).Debug("ignored because of if state")
                        }</span>
                }
        }
        <span class="cov8" title="1">GetLogger().WithFields(logrus.Fields{
                "parsed": parsedScript,
        }).Debug("... parsed result")
        return false, ExitOk, parsedScript</span>
}

func GetArgQuotedEntries(oristr string) ([]string, bool) <span class="cov8" title="1">{
        var result []string
        found := false
        re := regexp.MustCompile(`'[^']+'`)
        newStrs := re.FindAllString(oristr, -1)
        for _, s := range newStrs </span><span class="cov8" title="1">{
                found = true
                result = append(result, s)

        }</span>
        <span class="cov8" title="1">return result, found</span>
}

func SplitQuoted(oristr string, sep string) []string <span class="cov8" title="1">{
        var result []string
        var placeHolder map[string]string = make(map[string]string)

        found := false
        re := regexp.MustCompile(`'[^']+'`)
        newStrs := re.FindAllString(oristr, -1)
        i := 0
        for _, s := range newStrs </span><span class="cov8" title="1">{
                pl := "[$" + strconv.Itoa(i) + "]"
                placeHolder[pl] = strings.ReplaceAll(s, `'`, "")
                oristr = strings.Replace(oristr, s, pl, 1)
                found = true
                i++
        }</span>
        <span class="cov8" title="1">result = strings.Split(oristr, sep)
        if !found </span><span class="cov8" title="1">{
                return result
        }</span>

        <span class="cov8" title="1">for index, val := range result </span><span class="cov8" title="1">{
                if orgStr, fnd := placeHolder[val]; fnd </span><span class="cov8" title="1">{
                        result[index] = orgStr
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// YAMLToMap Convert yaml source string into map
func YAMLToMap(source string) (map[string]interface{}, error) <span class="cov0" title="0">{
        jsond, jerr := yaml.YAMLToJSON([]byte(source))
        if jerr != nil </span><span class="cov0" title="0">{
                return nil, jerr
        }</span>
        <span class="cov0" title="0">m := make(map[string]interface{})
        if err := json.Unmarshal([]byte(jsond), &amp;m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// ImportYAMLFile imports a yaml file as used for json map
func ImportYAMLFile(filename string) (map[string]interface{}, error) <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">jsond, jerr := yaml.YAMLToJSON(data)
        if jerr != nil </span><span class="cov0" title="0">{
                return nil, jerr
        }</span>
        <span class="cov8" title="1">m := make(map[string]interface{})
        if err = json.Unmarshal([]byte(jsond), &amp;m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if GetLogger().IsLevelEnabled(logrus.TraceLevel) </span><span class="cov0" title="0">{
                traceMap(m, filename)
        }</span>
        <span class="cov8" title="1">return m, nil</span>

}

// ImportJSONFile imports a json file for reading
func ImportJSONFile(fileName string) (map[string]interface{}, error) <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(fileName)
        if err != nil </span><span class="cov0" title="0">{
                GetLogger().Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">m := make(map[string]interface{})
        err = json.Unmarshal([]byte(data), &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                GetLogger().Error("ImportJSONFile : Unmarshal :", fileName, " : ", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">if GetLogger().IsLevelEnabled(logrus.TraceLevel) </span><span class="cov0" title="0">{
                traceMap(m, fileName)
        }</span>
        <span class="cov8" title="1">return m, nil</span>

}

func traceMap(mapShow map[string]interface{}, add string) <span class="cov0" title="0">{
        for k, v := range mapShow </span><span class="cov0" title="0">{
                //mapShow[k] = v
                //GetLogger().WithField("VAR", v).Trace("imported placeholder from " + add + " " + k)
                GetLogger().WithFields(logrus.Fields{
                        "source":  add,
                        "key":     k,
                        "content": v,
                }).Trace("imported content")
        }</span>
}

// MergeVariableMap merges two maps
func MergeVariableMap(mapin map[string]interface{}, maporigin map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if err := mergo.Merge(&amp;maporigin, mapin, mergo.WithOverride); err != nil </span><span class="cov0" title="0">{
                manout.Error("FATAL", "error while trying merge map")
                systools.Exit(10)
        }</span>
        <span class="cov8" title="1">return maporigin</span>
}

// ImportFolders import a list of folders recusiv
func ImportFolders(templatePath string, paths ...string) (string, error) <span class="cov8" title="1">{
        mapOrigin := GetOriginMap()

        template, terr := ImportFileContent(templatePath)
        if terr != nil </span><span class="cov0" title="0">{
                return "", terr
        }</span>

        <span class="cov8" title="1">for _, path := range paths </span><span class="cov8" title="1">{
                path = HandlePlaceHolder(path)
                GetLogger().WithField("folder", path).Debug("process path")
                pathMap, parseErr := ImportFolder(path, templatePath)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return "", parseErr
                }</span>
                <span class="cov8" title="1">mapOrigin = MergeVariableMap(pathMap, mapOrigin)
                UpdateOriginMap(mapOrigin)</span>
        }
        <span class="cov8" title="1">result, herr := HandleJSONMap(template, mapOrigin)
        if herr != nil </span><span class="cov0" title="0">{
                return "", herr
        }</span>
        <span class="cov8" title="1">template = result

        return template, nil</span>
}

func GetOriginMap() map[string]interface{} <span class="cov8" title="1">{
        exists, storedData := GetData("CTX_VAR_MAP")
        if exists </span><span class="cov8" title="1">{
                GetLogger().WithField("DATA", storedData).Trace("returning existing Variables map")
                return storedData
        }</span>
        <span class="cov8" title="1">mapOrigin := make(map[string]interface{})
        GetLogger().Trace("returning NEW Variables map")
        return mapOrigin</span>
}

func UpdateOriginMap(mapData map[string]interface{}) <span class="cov8" title="1">{
        GetLogger().WithField("DATA", mapData).Trace("update variables map")
        AddData("CTX_VAR_MAP", mapData)
}</span>

// ImportFolder reads folder recursiv and reads all .json, .yml and .yaml files
func ImportFolder(path string, _ string) (map[string]interface{}, error) <span class="cov8" title="1">{

        //var mapOrigin map[string]interface{}
        //mapOrigin = make(map[string]interface{})
        mapOrigin := GetOriginMap()

        err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">var jsonMap map[string]interface{}
                var loaderr error
                hit := false
                if !info.IsDir() </span><span class="cov8" title="1">{
                        var extension = filepath.Ext(path)
                        var basename = filepath.Base(path)
                        if basename == ".contxt.yml" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">switch extension </span>{
                        case ".json":<span class="cov8" title="1">
                                GetLogger().WithField("file", path).Debug("parsing included file (JSON)")
                                jsonMap, loaderr = ImportJSONFile(path)
                                hit = true</span>
                        case ".yaml", ".yml":<span class="cov8" title="1">
                                GetLogger().WithField("file", path).Debug("parsing included file (YAML)")
                                jsonMap, loaderr = ImportYAMLFile(path)
                                hit = true</span>
                        }
                        <span class="cov8" title="1">if loaderr != nil </span><span class="cov0" title="0">{
                                return loaderr
                        }</span>
                        <span class="cov8" title="1">if hit </span><span class="cov8" title="1">{
                                GetLogger().WithFields(logrus.Fields{
                                        "origin":   mapOrigin,
                                        "imported": jsonMap,
                                }).Trace("merged Variable map")
                                mapOrigin = MergeVariableMap(jsonMap, mapOrigin)
                                GetLogger().WithField("result", mapOrigin).Trace("result of merge")
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return mapOrigin, err</span>
}

// ImportFileContent imports a file and returns content as string
func ImportFileContent(filename string) (string, error) <span class="cov8" title="1">{
        GetLogger().WithField("file", filename).Debug("import file template")
        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("File reading error", err)
                return "", err
        }</span>
        <span class="cov8" title="1">return string(data), nil</span>
}

// HandleJSONMap parsing json content for text/template
func HandleJSONMap(tmpl string, m map[string]interface{}) (string, error) <span class="cov8" title="1">{
        tf := template.FuncMap{
                "isInt": func(i interface{}) bool </span><span class="cov0" title="0">{
                        v := reflect.ValueOf(i)
                        switch v.Kind() </span>{
                        case reflect.Int, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint32, reflect.Uint64, reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                                return true</span>
                        default:<span class="cov0" title="0">
                                return false</span>
                        }
                },
                "isString": func(i interface{}) bool <span class="cov0" title="0">{
                        v := reflect.ValueOf(i)
                        switch v.Kind() </span>{
                        case reflect.String:<span class="cov0" title="0">
                                return true</span>
                        default:<span class="cov0" title="0">
                                return false</span>
                        }
                },
                "isSlice": func(i interface{}) bool <span class="cov0" title="0">{
                        v := reflect.ValueOf(i)
                        switch v.Kind() </span>{
                        case reflect.Slice:<span class="cov0" title="0">
                                return true</span>
                        default:<span class="cov0" title="0">
                                return false</span>
                        }
                },
                "isArray": func(i interface{}) bool <span class="cov0" title="0">{
                        v := reflect.ValueOf(i)
                        switch v.Kind() </span>{
                        case reflect.Array:<span class="cov0" title="0">
                                return true</span>
                        default:<span class="cov0" title="0">
                                return false</span>
                        }
                },
                "isMap": func(i interface{}) bool <span class="cov0" title="0">{
                        v := reflect.ValueOf(i)
                        switch v.Kind() </span>{
                        case reflect.Map:<span class="cov0" title="0">
                                return true</span>
                        default:<span class="cov0" title="0">
                                return false</span>
                        }
                },
        }
        <span class="cov8" title="1">funcMap := MergeVariableMap(tf, sprig.FuncMap())
        tpl := template.New("contxt-map-string-func").Funcs(funcMap)
        tt, err := tpl.Parse(tmpl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">out := new(bytes.Buffer)
        tt.Execute(out, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return out.String(), nil</span>

}

/*
func IsList(i interface{}) bool {
        v := reflect.ValueOf(i).Kind()
        return v == reflect.Array || v == reflect.Slice
}

func IsNumber(i interface{}) bool {
        v := reflect.ValueOf(i).Kind()
        switch v {
        case reflect.Int, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint32, reflect.Uint64, reflect.Float32, reflect.Float64:
                return true
        default:
                return false
        }
}

func IsInt(i interface{}) bool {
        v := reflect.ValueOf(i).Kind()
        switch v {
        case reflect.Int, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint32, reflect.Uint64:
                return true
        default:
                return false
        }
}

func IsFloat(i interface{}) bool {
        v := reflect.ValueOf(i).Kind()
        return v == reflect.Float32 || v == reflect.Float64
}
*/
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
