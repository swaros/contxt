
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>configure: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/swaros/contxt/configure/config.go (7.6%)</option>
				
				<option value="file1">github.com/swaros/contxt/configure/version.go (14.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package configure

import (
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "os/user"
        "path/filepath"
        "strings"

        "github.com/swaros/contxt/systools"
        "github.com/swaros/manout"
)

const (
        // DefaultConfigFileName is the main config json file name.
        DefaultConfigFileName = "contxt_current_config.json"
        // DefaultPath this is the default path to store gocd configurations
        DefaultPath = "/.contxt/"
        // DefaultWorkspace this is the main configuration workspace
        DefaultWorkspace = "default_contxt_ws"
        // MirrorPath path for local mirror
        MirrorPath = "mirror/"
        // path where shared repositories are stored
        Sharedpath = "shared/"
)

// UsedConfig is the the current used configuration
var UsedConfig Configuration

var badCharacters = []string{
        "../",
        "&lt;!--",
        "--&gt;",
        "&lt;",
        "&gt;",
        "'",
        "\"",
        "&amp;",
        "$",
        "#",
        "{", "}", "[", "]", "=",
        ";", "?", "%20", "%22",
        "%3c",   // &lt;
        "%253c", // &lt;
        "%3e",   // &gt;
        "",      // &gt; -- fill in with % 0 e - without spaces in between
        "%28",   // (
        "%29",   // )
        "%2528", // (
        "%26",   // &amp;
        "%24",   // $
        "%3f",   // ?
        "%3b",   // ;
        "%3d",   // =
}

func RemoveBadCharacters(input string, dictionary []string) string <span class="cov0" title="0">{

        temp := input

        for _, badChar := range dictionary </span><span class="cov0" title="0">{
                temp = strings.Replace(temp, badChar, "", -1)
        }</span>
        <span class="cov0" title="0">return temp</span>
}

func SanitizeFilename(name string, relativePath bool) string <span class="cov0" title="0">{

        // default settings
        var badDictionary []string = badCharacters

        if name == "" </span><span class="cov0" title="0">{
                return name
        }</span>

        // if relativePath is TRUE, we preserve the path in the filename
        // If FALSE and will cause upper path foldername to merge with filename
        // USE WITH CARE!!!

        <span class="cov0" title="0">if !relativePath </span><span class="cov0" title="0">{
                // add additional bad characters
                badDictionary = append(badCharacters, "./")
                badDictionary = append(badDictionary, "/")
        }</span>

        // trim(remove)white space
        <span class="cov0" title="0">trimmed := strings.TrimSpace(name)

        // trim(remove) white space in between characters
        trimmed = strings.Replace(trimmed, " ", "", -1)

        // remove bad characters from filename
        trimmed = RemoveBadCharacters(trimmed, badDictionary)

        stripped := strings.Replace(trimmed, "\\", "", -1)

        return stripped</span>
}

func getUserDir() (string, error) <span class="cov0" title="0">{
        usr, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return usr.HomeDir, err</span>
}

// GetSharedPath returns the full path to the shared repository
func GetSharedPath(sharedName string) (string, error) <span class="cov0" title="0">{
        fileName := SanitizeFilename(sharedName, true) // make sure we have an valid filename
        sharedDir, err := getConfigPath(Sharedpath)    // get the path where we store shared repos
        if err == nil </span><span class="cov0" title="0">{
                var configPath = sharedDir + fileName // add the filename. sharedDir have the pathSeperator
                return configPath, err
        }</span>
        <span class="cov0" title="0">return "", err</span>
}

// InitConfig initilize the configuration files
func InitConfig() error <span class="cov0" title="0">{
        err := checkSetup()
        return err
}</span>

// ClearPaths removes all paths from current Workspace
func ClearPaths() <span class="cov0" title="0">{
        UsedConfig.Paths = nil
        SaveDefaultConfiguration(true)
}</span>

func createDefaultConfig() <span class="cov0" title="0">{
        UsedConfig.CurrentSet = DefaultWorkspace
}</span>

// ChangeWorkspace changing workspace
func ChangeWorkspace(workspace string, oldspace func(string) bool, newspace func(string)) error <span class="cov0" title="0">{
        // triggers execution of checking old Workspace
        canChange := oldspace(UsedConfig.CurrentSet)
        if canChange </span><span class="cov0" title="0">{
                // save current configuration
                SaveDefaultConfiguration(true)
                // change set name
                UsedConfig.CurrentSet = workspace
                SaveDefaultConfiguration(false)
                err := checkSetup()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
                <span class="cov0" title="0">SaveDefaultConfiguration(true)
                newspace(workspace)
                return nil</span>
        } else<span class="cov0" title="0"> {
                return errors.New("changing workspace failed.")
        }</span>
}

// RemoveWorkspace removes a workspace
func RemoveWorkspace(name string) <span class="cov0" title="0">{
        if name == UsedConfig.CurrentSet </span><span class="cov0" title="0">{
                fmt.Println("can not remove current workspace")
                return
        }</span>
        <span class="cov0" title="0">path, err := getConfigPath(name + ".json")
        if err == nil </span><span class="cov0" title="0">{
                var cfgExists, err = exists(path)
                if err == nil &amp;&amp; cfgExists </span><span class="cov0" title="0">{
                        os.Remove(path)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("no workspace exists with name: ", manout.MessageCln(manout.ForeLightYellow, name))
                        systools.Exit(5)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Println(err)
        }</span>
}

// SaveDefaultConfiguration stores the current configuration as default
func SaveDefaultConfiguration(workSpaceConfigUpdate bool) error <span class="cov0" title="0">{
        path, err := getConfigPath(DefaultConfigFileName)
        if err == nil </span><span class="cov0" title="0">{
                if err := SaveConfiguration(UsedConfig, path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // save workspace config too
                <span class="cov0" title="0">if workSpaceConfigUpdate </span><span class="cov0" title="0">{
                        pathWorkspace, secErr := getConfigPath(UsedConfig.CurrentSet + ".json")
                        if secErr == nil </span><span class="cov0" title="0">{
                                return SaveConfiguration(UsedConfig, pathWorkspace)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ListWorkSpaces : list all existing workspaces
func ListWorkSpaces() []string <span class="cov0" title="0">{
        var files []string
        var fullHomeDir string
        homeDir, err := getUserDir()
        if err == nil </span><span class="cov0" title="0">{
                fullHomeDir = homeDir + DefaultPath
                err := filepath.Walk(fullHomeDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        files = append(files, path)
                        return nil
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
        <span class="cov0" title="0">return files</span>
}

// DisplayWorkSpaces prints out all workspaces
func DisplayWorkSpaces() <span class="cov0" title="0">{
        //var files []string
        files := ListWorkSpaces()

        if len(files) &gt; 0 </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        var basePath = filepath.Base(file)
                        var extension = filepath.Ext(file)
                        // display json files only they are not the default config
                        if extension == ".json" &amp;&amp; basePath != DefaultConfigFileName </span><span class="cov0" title="0">{
                                basePath = strings.TrimSuffix(basePath, extension)
                                // we are also not interested in the default workspace
                                if basePath != DefaultWorkspace </span><span class="cov0" title="0">{
                                        fmt.Println(basePath)
                                }</span>
                        }
                }
        }
}

// GetWorkSpacesAsList prints out all workspaces
func GetWorkSpacesAsList() ([]string, bool) <span class="cov0" title="0">{
        var files []string
        var workspaces []string
        found := false
        files = ListWorkSpaces()

        if len(files) &gt; 0 </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        var basePath = filepath.Base(file)
                        var extension = filepath.Ext(file)
                        // display json files only they are not the default config
                        if extension == ".json" &amp;&amp; basePath != DefaultConfigFileName </span><span class="cov0" title="0">{
                                basePath = strings.TrimSuffix(basePath, extension)
                                // we are also not interested in the default workspace
                                if basePath != DefaultWorkspace </span><span class="cov0" title="0">{
                                        workspaces = append(workspaces, basePath)
                                        found = true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return workspaces, found</span>
}

// WorkSpaces handler to iterate all workspaces
func WorkSpaces(callback func(string)) <span class="cov0" title="0">{
        //var files []string
        files := ListWorkSpaces()

        if len(files) &gt; 0 </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        var basePath = filepath.Base(file)
                        var extension = filepath.Ext(file)
                        // display json files only they are not the default config
                        if extension == ".json" &amp;&amp; basePath != DefaultConfigFileName </span><span class="cov0" title="0">{
                                basePath = strings.TrimSuffix(basePath, extension)
                                // we are also not interested in the default workspace
                                if basePath != DefaultWorkspace </span><span class="cov0" title="0">{
                                        callback(basePath)
                                }</span>
                        }
                }
        }
}

// ShowPaths : display all stored paths in the workspace
func ShowPaths(current string) int <span class="cov0" title="0">{

        PathWorker(func(index int, path string) </span><span class="cov0" title="0">{
                if path == current </span><span class="cov0" title="0">{
                        fmt.Println(manout.MessageCln("\t[", manout.ForeLightYellow, index, manout.CleanTag, "]\t", manout.BoldTag, path))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(manout.MessageCln("\t ", manout.ForeLightBlue, index, manout.CleanTag, " \t", path))
                }</span>

        })
        <span class="cov0" title="0">return len(UsedConfig.Paths)</span>
}

// PathWorker executes a callback function in a path
func PathWorker(callback func(int, string)) error <span class="cov0" title="0">{
        cnt := len(UsedConfig.Paths)
        if cnt &lt; 1 </span><span class="cov0" title="0">{
                return errors.New("no paths actually stored ")
        }</span>
        <span class="cov0" title="0">for index, path := range UsedConfig.Paths </span><span class="cov0" title="0">{
                os.Chdir(path)
                callback(index, path)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func loadConfigurationFile(path string) error <span class="cov0" title="0">{
        file, _ := os.Open(path)
        defer file.Close()
        decoder := json.NewDecoder(file)

        return decoder.Decode(&amp;UsedConfig)
}</span>

// SaveConfiguration : stores configuration in given path
func SaveConfiguration(config Configuration, path string) error <span class="cov0" title="0">{
        b, _ := json.MarshalIndent(config, "", " ")
        return ioutil.WriteFile(path, b, 0644)

}</span>

// getConfigPath returns the user related  path
// it do not checks if this exists
func getConfigPath(fileName string) (string, error) <span class="cov0" title="0">{
        homeDir, err := getUserDir()
        if err == nil </span><span class="cov0" title="0">{
                var configPath = homeDir + DefaultPath + fileName
                return configPath, err
        }</span>
        <span class="cov0" title="0">return homeDir, err</span>
}

// AddPath adding a path if they not already exists
func AddPath(path string) <span class="cov8" title="1">{
        if PathExists(path) </span><span class="cov0" title="0">{
                fmt.Println(manout.MessageCln(manout.ForeYellow, "\tthe path is already in set ", manout.BoldTag, UsedConfig.CurrentSet))
                return
        }</span>

        <span class="cov8" title="1">UsedConfig.Paths = append(UsedConfig.Paths, path)</span>
}

// RemovePath removes a path from current set.
// returns true is path was found and removed
func RemovePath(path string) bool <span class="cov8" title="1">{
        var newSlice []string
        found := false
        if len(UsedConfig.Paths) &lt; 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, pathIn := range UsedConfig.Paths </span><span class="cov8" title="1">{
                if pathIn != path </span><span class="cov8" title="1">{
                        newSlice = append(newSlice, pathIn)
                }</span> else<span class="cov8" title="1"> {
                        found = true
                }</span>
        }
        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                UsedConfig.Paths = newSlice
        }</span>
        <span class="cov8" title="1">return found</span>
}

// PathExists checks if this path is stored in current Workspace
func PathExists(pathSearch string) bool <span class="cov8" title="1">{
        for _, path := range UsedConfig.Paths </span><span class="cov0" title="0">{
                if pathSearch == path </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// PathMeightPartOfWs checks if the path meight be a part of this workspace
func PathMeightPartOfWs(pathSearch string) bool <span class="cov0" title="0">{
        for _, path := range UsedConfig.Paths </span><span class="cov0" title="0">{
                if strings.Contains(pathSearch, path) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func checkSetup() error <span class="cov0" title="0">{
        homeDir, err := getUserDir()
        if err == nil </span><span class="cov0" title="0">{
                var dirPath = homeDir + DefaultPath
                var configPath = homeDir + DefaultPath + DefaultConfigFileName
                pathExists, err := exists(dirPath)
                // path dos not exists. create it
                if !pathExists &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err := os.Mkdir(dirPath, os.ModePerm)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                                return err
                        }</span>
                }

                <span class="cov0" title="0">configFileExists, err := exists(configPath)
                // no config file exists. create default config
                if !configFileExists &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        createDefaultConfig()
                }</span>

                // load config file
                <span class="cov0" title="0">if configFileExists &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        if lErr := loadConfigurationFile(configPath); lErr != nil </span><span class="cov0" title="0">{
                                return lErr
                        }</span>
                        <span class="cov0" title="0">if UsedConfig.CurrentSet == "" </span><span class="cov0" title="0">{
                                UsedConfig.CurrentSet = DefaultWorkspace
                                SaveDefaultConfiguration(false)
                        }</span>
                        // now copy content of set
                        <span class="cov0" title="0">pathWorkspace, secErr := getConfigPath(UsedConfig.CurrentSet + ".json")
                        if secErr == nil </span><span class="cov0" title="0">{
                                confPathExists, _ := exists(pathWorkspace)
                                if confPathExists </span><span class="cov0" title="0">{
                                        return loadConfigurationFile(pathWorkspace)
                                }</span> else<span class="cov0" title="0"> {
                                        UsedConfig.Paths = nil
                                }</span>
                        }
                }

        }
        <span class="cov0" title="0">return err</span>
}

func exists(path string) (bool, error) <span class="cov0" title="0">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2020 Thomas Ziegler &lt;thomas.zglr@googlemail.com&gt;. All rights reserved.
//
// Licensed under the MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package configure

import (
        "runtime"
        "strings"
)

// undefined variables they will be
// set by the linker
// example: go build -ldflags "-X github.com/swaros/contxt/context/configure.minversion=1-alpha -X github.com/swaros/contxt/context/configure.midversion=0 -X github.com/swaros/contxt/context/configure.mainversion=0"
// for all the variables you can use
//     go tool nm bin/contxt | grep version
// to figure out how the variable can be set

var build string
var mainversion string
var midversion string
var minversion string
var operatingSystem string

// GetVersion deleivers the current build version
func GetVersion() string <span class="cov0" title="0">{
        var outVersion = ""
        if mainversion != "" </span><span class="cov0" title="0">{
                outVersion = mainversion
        }</span>
        <span class="cov0" title="0">if midversion != "" </span><span class="cov0" title="0">{
                if outVersion != "" </span><span class="cov0" title="0">{
                        outVersion = outVersion + "." + midversion
                }</span> else<span class="cov0" title="0"> {
                        outVersion = midversion
                }</span>
        }

        <span class="cov0" title="0">if minversion != "" </span><span class="cov0" title="0">{
                if outVersion != "" </span><span class="cov0" title="0">{
                        outVersion = outVersion + "." + minversion
                }</span> else<span class="cov0" title="0"> {
                        outVersion = minversion
                }</span>
        }

        <span class="cov0" title="0">return outVersion</span>
}

func CheckCurrentVersion(askWithVersion string) bool <span class="cov0" title="0">{
        curentVersion := GetVersion()

        if curentVersion == "" || askWithVersion == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return CheckVersion(askWithVersion, curentVersion)</span>
}

func CheckVersion(askWithVersion string, versionStr string) bool <span class="cov8" title="1">{
        return askWithVersion &lt;= versionStr // til now this seems simple enough
}</span>

func GetOs() string <span class="cov8" title="1">{
        if operatingSystem == "" </span><span class="cov8" title="1">{
                return strings.ToLower(runtime.GOOS)
        }</span>
        <span class="cov0" title="0">return strings.ToLower(operatingSystem)</span>
}

// GetBuild returns Build time as build NO
func GetBuild() string <span class="cov0" title="0">{
        return build
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
