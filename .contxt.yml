version: "0.2.2"
config:
  variables:
      depbot-file: .github/dependabot.yml
      depbot-head: |
                  # To get started with Dependabot version updates, you'll need to specify which
                  # package ecosystems to update and where the package manifests are located.
                  # Please see the documentation for all configuration options:
                  # https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
                  version: 2
                  updates:
      depbot-template: |
                  ### dependencie for ${dep-bot-dep}
                    - package-ecosystem: gomod 
                      directory: ${dep-bot-dep} 
                      schedule:
                         interval: daily
                      assignees:
                         - swaros
      coverage-template-top: |
                    <!DOCTYPE html>
                    <html>
                      <head>
                        <meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
                        <title>Context Coverage Report overview</title>
                        <style>
                          body {
                            background: #333;
                            color: rgb(125, 125, 125);
                            font-family: Arial, Helvetica, sans-serif;
                          }
                          a, a:active {
                            color: rgb(200,200,200)
                          }
                          h1,h2,h3 {
                            color: white
                          }
                          .report {
                            display: block;
                            margin: 17px;
                            font-family: monospace;
                            white-space: break-spaces;
                          }
                        </style>
                       </head>
                       <body>
                        <h1>Contxt coverage Report</h1>
      coverage-template-bottom: |
                            </body>
                            </html>              
####### just for quick checking the go env on different machines
####### more then a note.
task:
  - id: go-check
    require:
      system: linux
    script:
      - echo ${GOROOT}
      - go env | grep GOROOT
      - go env | grep GOVERSION
      - go version 
 
  - id: go-check
    require:
      system: windows
    script:
      - echo ${GOROOT}
      - go env | Select-String GOROOT
      - go env | Select-String GOVERSION
      - go version

  - id: dos2unix
    require:
      system: linux
    script:
      - find . -type f -print0 | xargs -0 dos2unix

  ##### module based task #####
  ##### the definition for modules is stored in .modules.yml
  ##### here we check if all modules we expect
  ##### exists. and if not we create this modul
  ##### by using the regular go tool-set

  - id: modules-verify
    runTargets:
      - depandabot 
    needs:  
{{- range $k, $modul := $.module }}    
      - verify-modul-{{ $modul.modul }}
{{- end }}      
{{- range $k, $modul := $.module }}          

  ## create dir if not exists
  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
    require:      
      notExists:
        - ./module/{{ $modul.modul }}
    script:
      - mkdir ./module/{{ $modul.modul }}

  ## create mod if not exists
  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
    require:      
      notExists:
        - ./module/{{ $modul.modul }}/go.mod
    script:
      - |
        cd ./module/{{ $modul.modul }}
        go mod init github.com/swaros/contxt/{{ $modul.modul }}
      
  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
      ignoreCmdError: true
    require:
      system: linux
    script:                  
      - grep {{ $modul.modul }} go.work
    listener:
      - trigger:
          onerror: true
        action:
          script:
            - echo "update go.work for module {{ $modul.modul }}"
            - go work use module/{{ $modul.modul }}

{{- end }}

#### update depandabot
  - id: depandabot
    script:
      - echo "${depbot-head}" > ${depbot-file}
     {{- range $k, $deb := $.module }}
      - "#@set dep-bot-dep /module/{{ $deb.modul }}/" 
      - echo "${depbot-template}" >> ${depbot-file}
     {{- end }}  

#### update dependencies for all modules
  - id: cleanup-dependencies
    script:      
    {{- range $k, $test := $.module }}    
      - | 
       cd {{ $test.modul }}
       go mod tidy
       
    {{- end }}
      - git status

#### the next is all about tests

##### this is the regular test for all modules
  - id: test
    script:             
    {{- range $k, $test := $.module }}      
      - go test  -failfast ./module/{{ $test.modul }}/./...     
    {{- end }}      

##### like the regular test but now we update the coverage report
##### maybe i overlooked an option to summerize them, but
##### because it seems there is none, we just create oure own overview page
##### and link to the detailed html report.
##### also we add the -func output to the report
  - id: test-coverage
    script: 
      - echo "${coverage-template-top}" > ./docs/coverage.html                 
    {{- range $k, $test := $.module }}      
      - go test -cover ./module/{{ $test.modul }}/./... -coverprofile ./docs/test/coverage/test.{{ $test.modul }}.out
      - go tool cover -html ./docs/test/coverage/test.{{ $test.modul }}.out -o ./docs/test/coverage/{{ $test.modul }}.html
      - echo '<h2>{{ $test.modul }}</h2>' >> ./docs/coverage.html
      - echo '<div class="report">' >> ./docs/coverage.html
      - go tool cover -func ./docs/test/coverage/test.{{ $test.modul }}.out >> ./docs/coverage.html
      - echo '</div>' >> ./docs/coverage.html
      - echo '<a target="coverage_details" href="test/coverage/{{ $test.modul }}.html">report for {{ $test.modul }}</a>' >> ./docs/coverage.html
    {{- end }}
      - echo "${coverage-template-bottom}" >> ./docs/coverage.html

  - id: test-coverage
    require:
      system: linux
      exists:
        - docs/coverage.html
    script:
      - echo "try to open default browser with report ${CTX_PWD}"
      - xdg-open file://${CTX_PWD}/docs/coverage.html

#### same as test but running async
#### it is just faster
  - id: test-each
    needs:
    {{- range $k, $test := $.module }}
      - atest-{{ $test.modul }}
    {{- end }}
      
    {{- range $k, $test := $.module }}
  - id: atest-{{ $test.modul }}
    options:
      displaycmd: true
    script:
      - go test -failfast -timeout {{ $test.test.timeout }} ./module/{{ $test.modul }}/./...    
    {{- end }}  


  - id: set-version
    options:
      displaycmd: false
      invisible: true
    variables:
      bin-out: contxt
    require:
      system: linux
    script:
      - "#@var main-version cat docs/mainversion"
      - "#@var mid-version cat docs/midversion"
      - "#@var minor-version cat docs/minversion"
      - "#@var build-hash date -u +.%Y%m%d.%H%M%S"
      - "#@set bin-out contxt"

  - id: set-version
    options:
      displaycmd: false
      invisible: true
      maincmd: pwsh
      mainparams:
        - "-Command"
    require:
      system: windows
    script:
      - "#@var main-version type docs/mainversion"
      - "#@var mid-version type docs/midversion"
      - "#@var minor-version type docs/minversion"
      - "#@var build-hash Get-Date -UFormat \"%m.%d.%Y.%R\""
      - "#@set bin-out contxt.exe"

  - id: set-version
    options:
      displaycmd: false
      invisible: true
    script:
     - echo "version ${main-version}.${mid-version}.${minor-version} ${build-hash} out ${bin-out}"

  - id: build
    needs:
      - modules-verify
      - set-version
    next:
      - build-exec

  - id: build-exec
    options:
      displaycmd: false
      invisible: true
    require:
      variables:
        main-version: "*"
        mid-version: "*"
        minor-version: "*"
        bin-out: "*"
    next:
      - verify-build
    script:
      - echo "build start----"
      - echo "   target -- ${bin-out}"
      - go build -ldflags "-X github.com/swaros/contxt/configure.minversion=${minor-version} -X github.com/swaros/contxt/configure.midversion=${mid-version} -X github.com/swaros/contxt/configure.mainversion=${main-version} -X github.com/swaros/contxt/configure.build=${build-hash}" -o ./bin/${bin-out} cmd/cmd-contxt/main.go
      - echo "   done   -- build "

  - id: verify-build
    options:
      displaycmd: false
      invisible: true
    require:
      exists:
        - bin/${bin-out}
    script:
       - echo "verifiy build version. expected [${main-version}.${mid-version}.${minor-version} build ${build-hash}]"
       - bin/${bin-out} version

## install local. this is used by the Makefile
## because contxt can not update himself while it is running,
## or is just not installed yet
## so make runs the new builded contxt binary

  - id: install-local
    variables:
      local-install: "yes"
    needs:
      - build
    next:
      - install-local-bin

## check for ~/bin 
  - id: install-local-bin
    script:
      - echo "try the ${HOME}/bin usage"

## success for local bin/ 
  - id: install-local-bin 
    options:
      displaycmd: true
    require:
      exists:
        - ${HOME}/bin
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"
    script:
      - echo "we will use /bin/${bin-out}"
      - yes | cp -i bin/${bin-out} $HOME/bin/${bin-out} # # to solve the cp -i alias issue
      - echo "check versions"
      - contxt version
      


## fail for local bin/
  - id: install-local-bin
    options:
      displaycmd: true
    require:
      notExists:
        - ${HOME}/bin
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"
    script:
      - echo "${HOME}/bin not exists. will not be used"
    next:
      - install-local-dot-bin
    

  - id: install-local-dot-bin
    script:
      - echo "try $HOME/.local/bin/"

  ## fail test .local/bin
  - id: install-local-dot-bin
    require:
      notExists:
        - ${HOME}/.local/bin/
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"        
    script:
      - echo "no .local/bin dir"      
      
## if exists ...copy file
  - id: install-local-dot-bin
    require:
      exists:
        - ${HOME}/.local/bin/
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"        
    script:
      - echo "using ~/.local/bin/ to copy ${bin-out}"
      - yes | cp -i bin/${bin-out} $HOME/.local/bin/${bin-out}  # to solve the cp -i alias issue
      - echo "check versions"
      - contxt version

## tview test app #####
  - id: tview-build
    require:
      system: linux
    script:
      - echo "build tview for linux"
      - go build -o ./bin/tview-example cmd/cmd-tview/main.go
  
  - id: tview-build
    require:
      system: windows
    script:
      - echo "build tview for windows"
      - go build -o ./bin/tview-example.exe cmd/cmd-tview/main.go

  - id: tview-build
    require:
      system: linux
      exists:
        - bin/tview-example
    script:
      - chmod 755 bin/tview-example
      - echo "if not executed try to start the application with"
      - echo "./bin/tview-example"
      

  - id: tview-run
    needs:
      - tview-build

  - id: tview-run
    require:
      system: linux
      exists:
        - bin/tview-example
    script:
      - ./bin/tview-example        
  
  - id: tview-run
    require:
      system: windows
      exists:
        - bin/tview-example.exe
    script:
      - ./bin/tview-example.exe        
  