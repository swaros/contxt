# we use the build version for not running in a version conflict, if we do not have the new version installed
version: "{{$.build.version.main}}.{{$.build.version.mid}}.{{$.build.version.minor}}"

# define ours workspace
workspace:
  project: contxt
  role: root
  version: "{{$.release.version.main}}.{{$.release.version.mid}}.{{$.release.version.minor}}"

# we need a couple of imports to create some
# content depending the values we imported
# see .inc.contxt.yml where all value files defined
config:
  imports:
    - ./imports/dependabot.tpl depandabot
    - ./imports/coverage.html coverage
    - ./imports/Makefile.tpl makefile
    - ./imports/vscode.workspace.yml vscode-ws
    - ./imports/go_build.tpl build-action
    - ./imports/go_test.tpl test-action
    - ./imports/codehead.tpl codehead
    - ./imports/Dockerfile.ubuntu docker
  variables:
      build-main-file: {{$.release.main}}
      include-dev-externals: ""
      configmodul: github.com/swaros/contxt/module/configure
      coverage-report: ""
      depbot-file: .github/dependabot.yml
      licence_keyword: "MIT License"

###### contxt welcome message
###### just to display default variables
task:
  - id: welcome
    script:
      - echo "welcome to contxt"
      - echo " --- required build version        [ - {{$.build.version.main}}.{{$.build.version.mid}}.{{$.build.version.minor}} - ]"
      - echo " --- targets build version         [ - {{$.release.version.main}}.{{$.release.version.mid}}.{{$.release.version.minor}} - ]"
      - echo " --- self version                  [ - ${CTX_VERSION} - ]"
      - echo " --- operating system              [ - ${CTX_OS} - ]"
      - echo " --- build main file               [ - ${build-main-file} - ]"
{{- if $.WS0_contxt_root}} # always check if is set. without project info, this is not exists
      - echo " --- WS0_contxt_root = go/template [ - {{$.WS0_contxt_root}} - ]"
{{- end}}
      - echo " --- WS0_contxt_root = ctx/var     [ - ${WS0_contxt_root} - ]"
{{- range $k, $modul := $.module }}

  ### create tasks for external modules
  {{- if not $modul.local}}
      - echo " --- external modul  -->  {{ $modul.modul }} [ - {{ $modul.path }} - ]"
  {{- end }}
{{- end }}
    next:
      - go-check
  - id: dev
    variables:
      build-main-file: {{$.development.main}}
######
  - id: dev-external
    variables:
      include-dev-externals: "YES"

####### just for quick checking the go env on different machines
####### more then a note.
  - id: go-check
    require:
      system: linux
    script:
      - echo ${GOROOT}
      - go env | grep GOROOT
      - go env | grep GOVERSION
      - go version

  - id: go-check
    require:
      system: windows
    script:
      - echo ${GOROOT}
      - go env | Select-String GOROOT
      - go env | Select-String GOVERSION
      - go version

  - id: dos2unix
    require:
      system: linux
    script:
      - |
       if ! [ -x "$(command -v dos2unix)" ];
       then
         echo ""
         echo "<b:yellow><f:red> ERROR </>  <f:cyan>dos2unix</> is required"
         echo ""
       else
         find . -type f -print0 | xargs -0 dos2unix -v
         git status -s
       fi


  ##### module based task #####
  ##### the definition for modules is stored in .modules.yml
  ##### here we check if all modules we expect
  ##### exists. and if not we create this modul
  ##### by using the regular go tool-set

  ## clean tasks
  - id: clean
    require:
      system: linux
    runTargets:
      - clean-moduls
    script:
      - echo "clean all"
      - rm -rfv ./bin/*
      - rm -rfv ./docs/coverage.html

  - id: clean-moduls
    require:
      system: linux
    script:
      - echo "clean moduls"
{{- range $k, $modul := $.module }}
  {{- if $modul.clean}}
      - echo "   clean modul {{ $modul.modul }}"
      - |
        cd ./module/{{ $modul.modul }}/
        {{ range $k, $clean := $modul.clean }}
        echo "      remove {{ $clean }}"
        rm -rfv {{ $clean }}
        {{ end }}
  {{- end }}
{{- end }}

  ## update mai task
 
  - id: update-all
    runTargets:
      - modules-verify
      - makefile-update
      - licence-header-check
      - update-dependencies
    script:
      - echo "update all" 

  ## update makefile
  - id: makefile-update
    needs:
      - set-version
    script:
    - "#@var-to-file makefile Makefile"

  ## update github actions
  - id: github-actions-update
    script:
      - "#@var-to-file build-action .github/workflows/go.yml"
      - "#@var-to-file test-action .github/workflows/test.yml"

  ## verify the modules
  - id: modules-verify
    runTargets:
      - depandabot
      - github-actions-update
    needs:
{{- range $k, $modul := $.module }}
      - verify-modul-{{ $modul.modul }}
{{- end }}
{{- range $k, $modul := $.module }}

  ### create tasks for external modules
  {{- if not $modul.local}}
  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
    require:
      variables:
        include-dev-externals: "=YES"
    script:
      - echo "EXTERNAL >>> verify external module {{ $modul.modul }} on {{ $modul.path }}"

  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
    require:
      variables:
        include-dev-externals: "!YES"
    script:
      - echo "IGNORE EXTERNAL >>> {{ $modul.modul }}"
      - echo "to force external modules set var include-dev-externals to yes (ctx run modules-verify -v include-dev-externals=YES) "

  ### add external module
  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
      ignoreCmdError: true
    require:
      system: linux
      variables:
        include-dev-externals: "=YES"
      exists:
        - {{ $modul.path }}
    script:
      - grep {{ $modul.path }} go.work
    listener:
      - trigger:
          onerror: true
        action:
          script:
            - echo "EXTERNAL >>> update go.work for external module {{ $modul.modul }}"
            - echo "EXTERNAL >>> using path {{ $modul.path }}"
            - echo "             [go work use {{ $modul.path }}]"
            - go work use {{ $modul.path }}

  {{- end }}


  ### create tasks for local modul dependencies
  {{- if $modul.local}}
  ## create dir if not exists
  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
    require:
      notExists:
        - ./module/{{ $modul.modul }}
    script:
      - mkdir ./module/{{ $modul.modul }}

  ## create mod if not exists
  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
    require:
      notExists:
        - ./module/{{ $modul.modul }}/go.mod
    script:
      - |
        cd ./module/{{ $modul.modul }}
        go mod init github.com/swaros/contxt/module/{{ $modul.modul }}

  - id: verify-modul-{{ $modul.modul }}
    options:
      invisible: true
      ignoreCmdError: true
    require:
      system: linux
    script:
      - grep {{ $modul.modul }} go.work
    listener:
      - trigger:
          onerror: true
        action:
          script:
            - echo "update go.work for local module {{ $modul.modul }}"
            - go work use module/{{ $modul.modul }}
  {{- end}}
{{- end }}

#### generate visual studio code workspace file
  - id: code-workspace
    script:
       - "#@export-to-json vscode-ws VS_WS_CONFIG"
       - "#@var-to-file VS_WS_CONFIG contxt.code-workspace"

#### update depandabot
  - id: depandabot
    script:
       - "#@var-to-file depandabot ${depbot-file}"

#### update dependencies for all modules
  - id: update-dependencies
    script:
    {{- range $k, $test := $.module }}
    {{- if $test.local}}
      - |
       cd ${CTX_PWD}/module/{{ $test.modul }}
       go mod tidy
       cd ${CTX_PWD}
    {{- end }}
    {{- end }}
      - git status

#### the next is all about tests

##### this is the regular test for all modules
  - id: test
    script:
    {{- range $k, $test := $.module }}
    {{- if $test.local}}
      - echo "testing modul {{ $test.modul }}"
      - go test  -failfast ./module/{{ $test.modul }}/./...
    {{- end }}
    {{- end }}

##### like the regular test but now we update the coverage report
##### maybe i overlooked an option to summerize them, but
##### because it seems there is none, we just create oure own overview page
##### and link to the detailed html report.
##### also we add the -func output to the report

  - id: test-coverage
    require:
      notExists:
        - docs/test/coverage/
    script:
      - mkdir ./docs/test/coverage/

  - id: test-coverage
    script:
      - "#@set coverage-report <b></b>"
      {{- range $k, $test := $.module }}
      {{- if $test.local}}
      - go test -cover ./module/{{ $test.modul }}/./... -coverprofile ./docs/test/coverage/test.{{ $test.modul }}.out
      - go tool cover -html ./docs/test/coverage/test.{{ $test.modul }}.out -o ./docs/test/coverage/{{ $test.modul }}.html
      - "#@add coverage-report <h2>{{ $test.modul }}</h2>"
      - "#@add coverage-report <div class=\"report\">"
      - "#@var report-cover go tool cover -func ./docs/test/coverage/test.{{ $test.modul }}.out"
      - "#@add coverage-report ${report-cover}"
      - "#@add coverage-report </div>"
      - "#@add coverage-report <a target=\"coverage_details\" href=\"test/coverage/{{ $test.modul }}.html\">report for {{ $test.modul }}</a>"
    {{- end }}
    {{- end }}
      - "#@var-to-file coverage ./docs/coverage.html"

  - id: test-coverage
    require:
      exists:
        - docs/coverage.html
    script:
      - echo "try to open default browser with report ${CTX_PWD}"
      - echo "if this is not working, you can find the report here"
      - echo "file://${CTX_PWD}/docs/coverage.html"

  - id: test-coverage
    require:
      system: linux
      exists:
        - docs/coverage.html
    script:
      - xdg-open file://${CTX_PWD}/docs/coverage.html

  - id: test-coverage
    require:
      system: windows
      exists:
        - docs/coverage.html
    script:
      - Start-Process file://${CTX_PWD}/docs/coverage.html

#### same as test but running async
#### it is just faster
  - id: test-each
    needs:
    {{- range $k, $test := $.module }}
    {{- if $test.local}}
      - atest-{{ $test.modul }}
    {{- end }}
    {{- end }}

    {{- range $k, $test := $.module }}
    {{- if $test.local}}
  - id: atest-{{ $test.modul }}
    options:
      displaycmd: false
      panelsize: 25
    script:
      - echo "start async testing modul {{ $test.modul }}"
      - go test -count=1 -failfast -timeout {{ $test.test.timeout }} ./module/{{ $test.modul }}/./...
    {{- end }}
    {{- end }}

  - id: set-version
    options:
      invisible: true
    script:
      - "#@set main-version {{$.release.version.main}}"
      - "#@set mid-version {{$.release.version.mid}}"
      - "#@set minor-version {{$.release.version.minor}}"

  - id: set-version
    options:
      displaycmd: false
      invisible: true
    variables:
      bin-out: contxt
    require:
      system: linux
    script:
      - "#@var build-hash date -u +.%Y%m%d.%H%M%S"
      - "#@set bin-out contxt"

  - id: set-version
    options:
      displaycmd: false
      invisible: true
      maincmd: pwsh
      mainparams:
        - "-Command"
    require:
      system: windows
    script:
      - "#@var build-hash Get-Date -UFormat \"%m.%d.%Y.%R\""
      - "#@set bin-out contxt.exe"

  - id: set-version
    options:
      displaycmd: false
      invisible: true
    script:
     - echo "version ${main-version}.${mid-version}.${minor-version} ${build-hash} out ${bin-out}"

  - id: build
    needs:
      - modules-verify
      - set-version
    next:
      - build-exec

  - id: build-exec
    options:
      displaycmd: false
      invisible: true
    require:
      variables:
        main-version: "*"
        mid-version: "*"
        minor-version: "*"
        bin-out: "*"
    next:
      - verify-build
    script:
      - echo "start the build"
      - echo "   target  --> ${bin-out}"
      - echo "   version --> ${main-version}.${mid-version}.${minor-version} ${build-hash}"
      - echo "   main    --> ${build-main-file}"
      - go build -ldflags "-X ${configmodul}.minversion=${minor-version} -X ${configmodul}.midversion=${mid-version} -X ${configmodul}.mainversion=${main-version} -X ${configmodul}.build=${build-hash}" -o ./bin/${bin-out} ${build-main-file}
      - echo "   build   <-- done "

  - id: verify-build
    options:
      displaycmd: false
      invisible: true
    require:
      exists:
        - bin/${bin-out}
    script:
       - echo "verifiy build version. expected [${main-version}.${mid-version}.${minor-version} build ${build-hash}]"
       - bin/${bin-out} version

  - id: build-docker
    needs:
      - build
    script:
      - "#@var-to-file docker Dockerfile.tmp"
      - docker build -t contxt -f Dockerfile.tmp .
      - echo "docker run -it -v ${CTX_PWD}:/etc/contxt contxt run say-hello"
      - docker run -i -v ${CTX_PWD}:/etc/contxt contxt run say-hello

## a simple hello world
## just to test the docker image is working
  - id: say-hello
    script:
      - echo "hello world"

## install local. this is used by the Makefile
## because contxt can not update himself while it is running,
## or is just not installed yet
## so make runs the new builded contxt binary

  - id: install-local
    variables:
      local-install: "yes"
    needs:
      - build
    next:
      - install-local-bin

## check for ~/bin
  - id: install-local-bin
    script:
      - echo "try the ${HOME}/bin usage"

## success for local bin/
  - id: install-local-bin
    options:
      displaycmd: true
    require:
      exists:
        - ${HOME}/bin
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"
    script:
      - echo "we will use /bin/${bin-out}"
      - yes | cp -i bin/${bin-out} $HOME/bin/${bin-out} # # to solve the cp -i alias issue
      - echo "check versions"
      - contxt version


## fail for local bin/
  - id: install-local-bin
    options:
      displaycmd: true
    require:
      notExists:
        - ${HOME}/bin
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"
    script:
      - echo "${HOME}/bin not exists. will not be used"
    next:
      - install-local-dot-bin

  - id: install-local-dot-bin
    script:
      - echo "try $HOME/.local/bin/"

  ## fail test .local/bin
  - id: install-local-dot-bin
    require:
      notExists:
        - ${HOME}/.local/bin/
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"
    script:
      - echo "no .local/bin dir"

## if exists ...copy file
  - id: install-local-dot-bin
    require:
      exists:
        - ${HOME}/.local/bin/
      system: linux
      variables:
        local-install: "=yes"
        bin-out: "*"
    script:
      - echo "using ~/.local/bin/ to copy ${bin-out}"
      - yes | cp -i bin/${bin-out} $HOME/.local/bin/${bin-out}  # to solve the cp -i alias issue
      - echo "check versions"
      - contxt version

### licence check
  - id: licence-header-check
    options:
      displaycmd: false
      invisible: false
    require:
      system: linux
    next:
      - test-each
    script:
      - |
       GOFILES=$(find . -type f -name "*.go" ! -name "*_test.go" ! -path "./vendor/*" ! -path "./bin/*")
       while IFS= read -r gfile; do
          #echo "... $gfile ..."
          # check if file has licence header
          if ! grep -q "${licence_keyword}" "$gfile"; then
            echo "MISSING: $gfile is missing licence header"
            FCNT=$(cat $gfile)
            echo "${codehead} $FCNT" > $gfile
          else
            echo "OK: $gfile"
          fi
       done <<< "$GOFILES"
